Directory structure:
└── itsnotgoodname-dahua-rpc/
    ├── README.md
    ├── CHANGELOG.md
    ├── LICENSE
    ├── package.json
    ├── tsconfig.build.json
    ├── tsconfig.json
    ├── util.d.ts
    ├── .mocharc.json
    ├── lib/
    │   ├── index.ts
    │   ├── rpcLogin.ts
    │   ├── util.ts
    │   ├── rpc/
    │   │   ├── Alarm.ts
    │   │   ├── AroudWifi.ts
    │   │   ├── AsyncDeviceManager.ts
    │   │   ├── AudioRecordManager.ts
    │   │   ├── AuthPTZ.ts
    │   │   ├── Backup.ts
    │   │   ├── BlueToothDeviceManager.ts
    │   │   ├── CertManager.ts
    │   │   ├── CloudUpgrader.ts
    │   │   ├── CoaxialControlIO.ts
    │   │   ├── CommPort.ts
    │   │   ├── ConfigManager.ts
    │   │   ├── DdnsClient.ts
    │   │   ├── DevAudioDetect.ts
    │   │   ├── DevAudioEncode.ts
    │   │   ├── DevAudioInput.ts
    │   │   ├── DevAudioOutput.ts
    │   │   ├── DevFlashLampManager.ts
    │   │   ├── DevInit.ts
    │   │   ├── DevIntelliTracker.ts
    │   │   ├── DevStorage.ts
    │   │   ├── DevVariableCapsManager.ts
    │   │   ├── DevVideoAnalyse.ts
    │   │   ├── DevVideoDetect.ts
    │   │   ├── DevVideoEncode.ts
    │   │   ├── DevVideoInput.ts
    │   │   ├── DevVideoOutput.ts
    │   │   ├── DigitalCertificate.ts
    │   │   ├── DockUser.ts
    │   │   ├── Encode.ts
    │   │   ├── EventManager.ts
    │   │   ├── ExternalSensorManager.ts
    │   │   ├── FaceBoard.ts
    │   │   ├── FaceFlowStat.ts
    │   │   ├── FaceRecognitionServer.ts
    │   │   ├── FileManager.ts
    │   │   ├── FlirDebug.ts
    │   │   ├── FontManager.ts
    │   │   ├── FtpTest.ts
    │   │   ├── GB35114Encrypt.ts
    │   │   ├── GpsControl.ts
    │   │   ├── Gyro.ts
    │   │   ├── index.ts
    │   │   ├── InstallManager.ts
    │   │   ├── IntelliSnapshot.ts
    │   │   ├── IntervideoClient.ts
    │   │   ├── IntervideoManager.ts
    │   │   ├── LensFunc.ts
    │   │   ├── License.ts
    │   │   ├── Log.ts
    │   │   ├── LogOnlineBackup.ts
    │   │   ├── MagicBox.ts
    │   │   ├── masterSlaveGroup.ts
    │   │   ├── MediaFileFind.ts
    │   │   ├── MultiVideo.ts
    │   │   ├── Nat.ts
    │   │   ├── NetApp.ts
    │   │   ├── OSDManager.ts
    │   │   ├── PasswdFind.ts
    │   │   ├── PeripheralChip.ts
    │   │   ├── PortraitFlowStat.ts
    │   │   ├── PrivacyMasking.ts
    │   │   ├── PTZ.ts
    │   │   ├── PTZBase.ts
    │   │   ├── PtzPeripheral.ts
    │   │   ├── PtzViewRange.ts
    │   │   ├── RainBrush.ts
    │   │   ├── RecordFinder.ts
    │   │   ├── RecordManager.ts
    │   │   ├── RecordUpdater.ts
    │   │   ├── RemoteUpgrader.ts
    │   │   ├── RfidManager.ts
    │   │   ├── ScenicSpot.ts
    │   │   ├── SDEncrypt.ts
    │   │   ├── Security.ts
    │   │   ├── SnapManager.ts
    │   │   ├── Speak.ts
    │   │   ├── Storage.ts
    │   │   ├── StreamUrlService.ts
    │   │   ├── System.ts
    │   │   ├── TemperCorrection.ts
    │   │   ├── ThermographyLog.ts
    │   │   ├── ThermoPrivateParam.ts
    │   │   ├── trafficFlowStat.ts
    │   │   ├── TrafficSnap.ts
    │   │   ├── TrafficStatistic.ts
    │   │   ├── Upgrader.ts
    │   │   ├── UpgraderInstall.ts
    │   │   ├── UPnPPortmap.ts
    │   │   ├── UserManager.ts
    │   │   ├── UWB.ts
    │   │   ├── vehiclesDistribution.ts
    │   │   ├── videoCalibrateServer.ts
    │   │   ├── VideoInAnalyse.ts
    │   │   ├── VideoProcessManager.ts
    │   │   ├── VideoStatServer.ts
    │   │   ├── WebInit.ts
    │   │   ├── WideViewControl.ts
    │   │   ├── wire802File.ts
    │   │   ├── WlanManager.ts
    │   │   ├── WorkDirectory.ts
    │   │   └── WorkGroup.ts
    │   └── rpcBase/
    │       ├── Global.ts
    │       └── index.ts
    ├── test/
    │   ├── env.ts
    │   ├── rpc.spec.ts
    │   ├── rpcLogin.spec.ts
    │   └── util.spec.ts
    └── .github/
        └── workflows/
            └── npm-publish.yml

================================================
FILE: README.md
================================================
# dahua-rpc

[![GitHub](https://img.shields.io/github/license/itsnotgoodname/dahua-rpc)](https://github.com/ItsNotGoodName/dahua-rpc/blob/master/LICENSE)
[![GitHub last commit](https://img.shields.io/github/last-commit/itsnotgoodname/dahua-rpc)](https://github.com/ItsNotGoodName/dahua-rpc)
[![npm](https://img.shields.io/npm/v/dahua-rpc)](https://www.npmjs.com/package/dahua-rpc)

**Use this library at your own risk as incorrect usage may brick your IP camera.**

Node.js library for Dahua's RPC API.

The code is adapted from the Web UI of a `IPC-T5442TM-AS` that is running firmware that is dated `2020-10-19`.
The following changes have been made to the original.

- [jQuery](https://jquery.com/) replaced with modern JavaScript
- Methods that require encryption are either removed or changed to not use encryption
- Each RPC module has been extracted into seperate files
- `RPCBase` class changed to only contain the `Global` module while the `RPC` class contains the rest

It is recommended to use [TypeScript](https://www.typescriptlang.org/) in your project.
Method arguments are mostly typed but what they return may depend on the camera's model.

This library won't work in web browsers due to [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).

# Installing

```
npm install dahua-rpc
```

# Example

## Get MagicBox Information

```ts
import { RPC, RPCLogin } from "dahua-rpc";
// const { RPC, RPCLogin } = require("dahua-rpc");

function print(data) {
  console.log(JSON.stringify(data));
}

async function main() {
  const ip = "192.168.1.108";
  const username = "admin";
  const password = "password";

  const rpc = new RPC(ip);
  const rpcLogin = new RPCLogin(rpc);

  // Login
  await rpcLogin.login(username, password);

  print(await rpc.MagicBox.getCPUUsage(0));
  print(await rpc.MagicBox.getDeviceClass());
  print(await rpc.MagicBox.getDeviceType());
  print(await rpc.MagicBox.getHardwareVersion());
  print(await rpc.MagicBox.getMarketArea());
  print(await rpc.MagicBox.getMemoryInfo());
  print(await rpc.MagicBox.getProcessInfo());
  // print(await rpc.MagicBox.getSerialNo());
  print(await rpc.MagicBox.getSoftwareVersion());
  print(await rpc.MagicBox.getUpTime());
  print(await rpc.MagicBox.getVendor());

  // Logout
  await rpcLogin.logout();
}

main();
```

### Output

```json
30
"IPC"
"IPC-T5442TM-AS-3.6mm"
"1.00"
"Oversea"
{"free":9613312,"total":274636800}
"HI3516DV300"
{"version":{"Build":"20201019","BuildDate":"2020-10-19","SecurityBaseLineVersion":"V2.1","Version":"2.800.15OG004.0.R","WebVersion":"V3.2.1.948164"}}
{"Last":1038879,"Total":1312244}
"General"
```

# Testing

The following environment variables are required for running tests. They can be placed in the `.env` file.

```shell
RPC_USERNAME=admin
RPC_PASSWORD=password
RPC_IP=192.168.1.108
```

Run tests with the following command.

```
npm run test:all
```

# [Changelog](https://github.com/ItsNotGoodName/dahua-rpc/blob/master/CHANGELOG.md)

# To Do

- Document how the RPC API works
- Finish typing RPC methods
- Add event emitter



================================================
FILE: CHANGELOG.md
================================================
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.2.0] - 2023-02-10

### Added

- Added AudioRecordManager, Speak, UPnPPortmap, and WorkDirectory modules.
- Added month bitmap utility functions.
- Added fromTimestamp, toTimestamp, and createFindFileCondition utility functions.
- Added createCookie and createRPCLoadfileURL utility functions.

### Fixed

- Fixed MediaFileFind module's types.

## [0.1.0] - 2023-02-04

### Added

- First release.



================================================
FILE: LICENSE
================================================
Copyright 2023 ItsNotGoodName

Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.



================================================
FILE: package.json
================================================
{
  "name": "dahua-rpc",
  "version": "0.2.0",
  "description": "Node.js library for Dahua's RPC API.",
  "main": "./dist/index.js",
  "types": "./dist/types/index.d.ts",
  "files": [
    "dist",
    "util.d.ts",
    "CHANGELOG.md"
  ],
  "scripts": {
    "clean": "rm -rf ./dist",
    "build": "npm run clean && tsc -p tsconfig.build.json",
    "prepack": "npm run build",
    "test": "mocha -g util",
    "test:all": "mocha"
  },
  "keywords": [
    "dahua"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/ItsNotGoodName/dahua-rpc.git"
  },
  "author": "ItsNotGoodName",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/ItsNotGoodName/dahua-rpc/issues"
  },
  "homepage": "https://github.com/ItsNotGoodName/dahua-rpc#readme",
  "devDependencies": {
    "@types/chai": "^4.3.4",
    "@types/md5": "^2.3.2",
    "@types/mocha": "^10.0.1",
    "@types/node": "^18.11.18",
    "@typescript-eslint/eslint-plugin": "^5.49.0",
    "@typescript-eslint/parser": "^5.49.0",
    "chai": "^4.3.7",
    "dotenv": "^16.0.3",
    "eslint": "^8.32.0",
    "mocha": "^10.2.0",
    "ts-node": "^10.9.1",
    "typescript": "^4.9.4"
  },
  "eslintConfig": {
    "ignorePatterns": [
      "**/vendor/*.js"
    ],
    "extends": [
      "eslint:recommended",
      "plugin:@typescript-eslint/recommended"
    ],
    "parser": "@typescript-eslint/parser",
    "plugins": [
      "@typescript-eslint"
    ],
    "root": true
  },
  "dependencies": {
    "axios": "^1.3.0",
    "md5": "^2.3.0"
  },
  "exports": {
    ".": {
      "types": "./dist/types/index.d.ts",
      "default": "./dist/index.js"
    },
    "./util": {
      "types": "./dist/types/util.d.ts",
      "default": "./dist/util.js"
    }
  }
}



================================================
FILE: tsconfig.build.json
================================================
{
  "extends":"./tsconfig.json",
  "include": [
    "lib"
  ],
}


================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */
    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */
    /* Language and Environment */
    "target": "ES2016", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */
    /* Modules */
    "module": "CommonJS", /* Specify what module code is generated. */
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */
    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */
    /* Emit */
    "declaration": true, /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    "declarationMap": true, /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    "sourceMap": true, /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./dist", /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    "declarationDir": "./dist/types", /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */
    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true, /* Ensure that casing is correct in imports. */
    /* Type Checking */
    "strict": true, /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */
    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  },
}


================================================
FILE: util.d.ts
================================================
export * from "./dist/types/util";



================================================
FILE: .mocharc.json
================================================
{
  "extension": [
    "ts"
  ],
  "spec": "./**/*.spec.ts",
  "require": "ts-node/register"
}


================================================
FILE: lib/index.ts
================================================
import { RPC } from "./rpc";
import { RPCBase, TOptions, TResponse, TRPC, Code } from "./rpcBase";
import { RPCLogin } from "./rpcLogin";

export { RPC, RPCBase, TOptions, TResponse, TRPC, Code, RPCLogin };

export default RPC;



================================================
FILE: lib/rpcLogin.ts
================================================
import { Code, RPCBase } from "./rpcBase";
import md5 from "md5";

function getAuth(
  username: string,
  password: string,
  params: { encryption: string; random: string; realm: string }
) {
  switch (params.encryption) {
    case "Basic":
      return Buffer.from(username + ":" + password).toString("base64");
    case "Default":
      return md5(
        username +
          ":" +
          params.random +
          ":" +
          md5(username + ":" + params.realm + ":" + password).toUpperCase()
      ).toUpperCase();
    default:
      return password;
  }
}

/**
 * Login manager for logging in and keeping the connection alive.
 */
export class RPCLogin {
  _username = "";
  _password = "";
  _retries = 0;
  _keepAliveID?: NodeJS.Timeout;

  constructor(readonly rpcBase: RPCBase) {}

  _keepAliveFunc = (() => {
    return this.rpcBase.Global.keepAlive()
      .then(() => {
        this._retries = 0;
      })
      .catch((b) => {
        if (b.error && b.error.code && b.error.code === 287637504)
          return clearInterval(this._keepAliveID);
        else {
          // TODO: publish reconnect event
          this._login().catch(function (e) {
            console.log(e);
          });
        }
      });
  }).bind(this);

  logout() {
    clearInterval(this._keepAliveID);
    this._keepAliveID = undefined;
    return this.rpcBase.Global.logout();
  }

  login(
    username: string,
    password: string,
    loginType = "Direct",
    clientType?: string
  ) {
    this._username = username;
    this._password = password;
    return this._login(loginType, clientType);
  }

  _login(loginType = "Direct", clientType?: string) {
    return new Promise<null>((resolve, reject) => {
      this.rpcBase.Global.firstLogin(this._username, { loginType }, clientType)
        .then((res) => {
          if (
            !(
              res &&
              res.error &&
              (res.error.code == 268632079 || res.error.code === 401)
            )
          ) {
            if (res && res.error && res.error.code === 400) {
              return reject(Code.USER_NOT_VALID);
            }

            if (res && res.error && res.error.code === 486) {
              return reject(Code.BUSY);
            }

            return reject();
          }

          this.rpcBase.Global.secondLogin(
            this._username,
            getAuth(this._username, this._password, res.params),
            {
              loginType:
                res.params.encryption === "WatchNet" ? "WatchNet" : loginType,
              authorityType: res.params.encryption,
            }
          )
            .then(() => {
              clearInterval(this._keepAliveID);
              this._keepAliveID = setInterval(this._keepAliveFunc, 60000);
              resolve(null);
            })
            .catch(function (e) {
              if (
                !(e && e.params && e.params.error) &&
                e &&
                e.error &&
                e.error.code
              )
                if (e.params) {
                  reject(e.params);
                } else {
                  reject(e && e.error && e.error.code);
                }
              else {
                switch (e && e.params && e.params.error) {
                  case "UserNotValidt":
                    reject(Code.USER_NOT_VALID);
                    break;
                  case "PasswordNotValid":
                    reject(Code.PASSWORD_NOT_VALID);
                    break;
                  case "InBlackList":
                    reject(Code.IN_BLACK_LIST);
                    break;
                  case "HasBeedUsed":
                    reject(Code.HAS_BEEN_USED);
                    break;
                  case "HasBeenLocked":
                    reject(Code.HAS_BEEN_LOCKED);
                    break;
                  default:
                    reject();
                }
              }
            });
        })
        .catch(reject);
    });
  }
}



================================================
FILE: lib/util.ts
================================================
import type { FindFileCondition } from "./rpc/MediaFileFind";

export function dayInBitmap(bitmap: number, day: number): boolean {
  return !!((bitmap >>> 1) & (1 << (day - 1)));
}

export function daysFromBitmap(bitmap: number, maxDays = 32): number[] {
  const days = [];
  for (let day = 1; day <= maxDays; day++) {
    if ((bitmap >>> 1) & (1 << (day - 1))) {
      days.push(day);
    }
  }

  return days;
}

export function toTimestamp(date: Date): string {
  return date.toLocaleString("sv-SE");
}

export function fromTimestamp(timestamp: string): Date {
  const offset = 0 - new Date().getTimezoneOffset() / 60;
  return new Date(
    timestamp.substring(0, 10) +
      "T" +
      timestamp.substring(11) +
      ".000" +
      (offset > 0 ? "+" : "-") +
      Math.abs(offset).toString().padStart(2, "0") +
      ":00"
  );
}

export function createFindFileCondition(
  {
    Channel,
    Dirs,
    StartTime,
    EndTime,
    Redundant,
    Order,
  }: {
    Channel: number;
    Dirs: string[];
    StartTime: string;
    EndTime: string;
    Order?: string;
    Redundant?: string;
  },
  type: "All" | "Timing" | "Event" | "Alarm" | "Manual" | "Picture" = "All"
): FindFileCondition {
  const condition: FindFileCondition = {
    Channel,
    StartTime,
    EndTime,
    Dirs,
    Redundant: Redundant ?? "Exclusion",
    Order: Order ?? "Ascent",
    Types: ["dav"],
    Flags: [""],
    Events: null,
  };

  switch (type) {
    case "All":
      condition.Types = ["dav"];
      condition.Flags = ["Timing", "Event", "Event", "Manual"];
      break;
    case "Timing":
      condition.Types = ["dav"];
      condition.Flags = ["Timing"];
      break;
    case "Event":
      condition.Types = ["dav"];
      condition.Flags = ["Event"];
      break;
    case "Alarm":
      condition.Types = ["dav"];
      condition.Flags = ["Event"];
      break;
    case "Manual":
      condition.Types = ["dav"];
      condition.Flags = ["Manual"];
      break;
    case "Picture":
      condition.Types = ["jpg"];
      condition.Flags = ["Timing", "Event", "Event"];
  }

  return condition;
}

export function createCookie(username: string, session: string) {
  return `username=${username}; WebClientSessionID=${session}; DWebClientSessionID=${session}; DhWebClientSessionID=${session}`;
}

export function createRPCLoadfileURL(
  baseURL: string,
  filePath: string
): string {
  return `${baseURL}/RPC_Loadfile${filePath}`;
}



================================================
FILE: lib/rpc/Alarm.ts
================================================
import { RPCBase } from "../rpcBase";

export function Alarm(this: RPCBase) {
  return {
    getInSlots: () => {
      return this.send<{ inputs?: number }>("alarm.getInSlots").then(function (
        a
      ) {
        return a.params.inputs || 0;
      });
    },
    getOutSlots: () => {
      return this.send<{ outputs?: number }>("alarm.getOutSlots").then(
        function (a) {
          return a.params.outputs || 0;
        }
      );
    },
    getAlarmCaps: () => {
      return this.send<{
        caps?: {
          AlarmPir?: boolean;
          Flash?: boolean;
          SupportAlarmInDisableLinkage?: boolean;
          SupportConfigurableAlarm?: boolean;
        };
      }>("alarm.getAlarmCaps").then(function (a) {
        return a.params.caps || {};
      });
    },
    getOutState: () => {
      return this.send<{ state: number }>("alarm.getOutState").then(function (
        a
      ) {
        return a.params.state;
      });
    },
  };
}



================================================
FILE: lib/rpc/AroudWifi.ts
================================================
import { RPCBase } from "../rpcBase";

export function AroudWifi(this: RPCBase) {
  return {
    getCaps: () => {
      return this.send("AroudWifi.getCaps").then(function (a) {
        return a.params;
      });
    },
    getApsInfoState: () => {
      return this.send("AroudWifi.getApsInfoState").then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/AsyncDeviceManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function AsyncDeviceManager(this: RPCBase) {
  return {
    getDeviceInfoEx: (a: object[] | object | null) => {
      return this.send("AsyncDeviceManager.getDeviceInfoEx", a).then(function (
        a
      ) {
        return a.params;
      });
    },
    removeDevice: (a: object[] | object | null) => {
      return this.send("AsyncDeviceManager.removeDevice", a).then(function (a) {
        return a.params;
      });
    },
    addCustomDevice: (a: object[] | object | null) => {
      return this.send("AsyncDeviceManager.addCustomDevice", a).then(function (
        a
      ) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/AudioRecordManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function AudioRecordManager(this: RPCBase) {
  return {
    getStateAll: () => {
      return this.send<{ state: unknown }>(
        "audioRecordManager.getStateAll"
      ).then(function (a) {
        return a.params.state;
      });
    },
    startChannel: (stream: unknown, path: unknown, channel?: number) => {
      return this.send("audioRecordManager.startChannel", {
        stream: stream,
        path: path,
        channel: channel || 0,
      });
    },
    stopChannel: (stream: unknown, channel?: number) => {
      return this.send("audioRecordManager.stopChannel", {
        stream: stream,
        channel: channel || 0,
      });
    },
    startName: (stream: unknown, channel?: number) => {
      return this.send<{ name: unknown }>("audioRecordManager.startName", {
        stream: stream,
        channel: channel || 0,
      }).then(function (a) {
        return a.params.name;
      });
    },
    stopName: (stream: unknown, channel?: number) => {
      return this.send<{ name: unknown }>("audioRecordManager.stopName", {
        stream: stream,
        channel: channel || 0,
      }).then(function (a) {
        return a.params.name;
      });
    },
  };
}



================================================
FILE: lib/rpc/AuthPTZ.ts
================================================
import { RPCBase } from "../rpcBase";

export function AuthPTZ(this: RPCBase) {
  return {
    getMoveStatus: (channel: number) => {
      return this.send("ptzBase.getMoveStatus", { channel: channel }).then(
        function (a) {
          return a.params;
        }
      );
    },
  };
}



================================================
FILE: lib/rpc/Backup.ts
================================================
import { RPCBase } from "../rpcBase";

export function Backup(this: RPCBase) {
  return {
    checkCondition: (startTime: unknown, endTime: unknown) => {
      return this.send("Backup.checkCondition", {
        startTime: startTime,
        endTime: endTime,
      }).then(function (a) {
        return a.params;
      });
    },
    manualStart: (startTime: unknown, endTime: unknown) => {
      return this.send("Backup.manualStart", {
        startTime: startTime,
        endTime: endTime,
      }).then(function (a) {
        return a.params;
      });
    },
    manualStop: (taskID: unknown) => {
      return this.send("Backup.manualStop", { taskID: taskID }).then(function (
        a
      ) {
        return a.params;
      });
    },
    getManualProgress: (taskID: unknown) => {
      return this.send("Backup.getManualProgress", { taskID: taskID }).then(
        function (a) {
          return a.params;
        }
      );
    },
  };
}



================================================
FILE: lib/rpc/BlueToothDeviceManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function BlueToothDeviceManager(this: RPCBase) {
  return {
    scan: () => {
      return this.send("BlueToothDeviceManager.scan").then(function (a) {
        return a.params;
      });
    },
    getModuleState: () => {
      return this.send("BlueToothDeviceManager.getModuleState").then(function (
        a
      ) {
        return a.params;
      });
    },
    getConnectState: (slaveMac: unknown) => {
      return this.send("BlueToothDeviceManager.getConnectState", {
        slaveMac: slaveMac,
      }).then(function (a) {
        return a.params;
      });
    },
    pair: (slaveMac: unknown) => {
      return this.send("BlueToothDeviceManager.pair", {
        slaveMac: slaveMac,
      }).then(function (a) {
        return a.params;
      });
    },
    getCaps: () => {
      return this.send<{ caps: unknown }>(
        "BlueToothDeviceManager.getCaps"
      ).then(function (a) {
        return a.params.caps;
      });
    },
  };
}



================================================
FILE: lib/rpc/CertManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function CertManager(this: RPCBase) {
  return {
    getSvrCertInfo: () => {
      return this.send("CertManager.getSvrCertInfo").then(function (a) {
        return a.params;
      });
    },
    importSvrCert: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.send("CertManager.importSvrCert", {
        salt: salt,
        cipher: cipher,
        content: content,
      });
    },
    exportRootCert: () => {
      return this.send("CertManager.exportRootCert");
    },
    getSvrCertSubject: () => {
      return this.send("CertManager.getSvrCertSubject");
    },
    removeSvrCert: () => {
      return this.send("CertManager.removeSvrCert");
    },
  };
}



================================================
FILE: lib/rpc/CloudUpgrader.ts
================================================
import { RPCBase } from "../rpcBase";

export function CloudUpgrader(this: RPCBase) {
  return {
    getAutoCheck: () => {
      return this.send("CloudUpgrader.getAutoCheck").then(function (a) {
        return a.params ? a.params : a;
      });
    },
    setAutoCheck: (flag: unknown) => {
      return this.send("CloudUpgrader.setAutoCheck", { flag: flag }).then(
        function (a) {
          return a.params ? a.params : a;
        }
      );
    },
    check: (way: unknown) => {
      return this.send("CloudUpgrader.check", { way: way }).then(function (a) {
        return a.params ? a.params : a;
      });
    },
    execute: (NewVersion: unknown, way: unknown) => {
      return this.send("CloudUpgrader.execute", {
        NewVersion: NewVersion,
        way: way,
      }).then(function (a) {
        return a.params ? a.params : a;
      });
    },
    getState: () => {
      return this.send<{
        Progress: number;
        State: string;
      }>("CloudUpgrader.getState").then(function (a) {
        return a.params;
      });
    },
    cancel: () => {
      return this.send("CloudUpgrader.cancel").then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/CoaxialControlIO.ts
================================================
import { RPCBase } from "../rpcBase";

export function CoaxialControlIO(this: RPCBase) {
  return {
    getStatus: (channel?: number) => {
      return this.send<{
        WhiteLight: string;
        Speaker: string;
      }>("CoaxialControlIO.getStatus", { channel: channel || 0 }).then(
        function (a) {
          return a.params;
        }
      );
    },
    getCaps: (channel?: number) => {
      return this.send<{
        SupportControlFullcolorLight?: number;
        SupportControlLight?: number;
        SupportControlSpeaker?: number;
      }>("CoaxialControlIO.getCaps", { channel: channel || 0 }).then(function (
        a
      ) {
        return a.params;
      });
    },
    control: (info: unknown, channel?: number) => {
      return this.send("CoaxialControlIO.control", {
        channel: channel || 0,
        info: info,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/CommPort.ts
================================================
import { RPCBase } from "../rpcBase";

export function CommPort(this: RPCBase) {
  const instance = this.sendSetup("commPort.factory.instance");
  return {
    instance,
    getProtocolList: () => {
      return instance().then(
        (a) => {
          return this.send<{ list: unknown }>(
            "commPort.getProtocolList",
            void 0,
            {
              object: a.result,
            }
          ).then(function (a) {
            return a.params.list;
          });
        },
        () => {
          return this.send<{ list: unknown }>("commPort.getProtocolList").then(
            function (a) {
              return a.params.list;
            }
          );
        }
      );
    },
  };
}



================================================
FILE: lib/rpc/ConfigManager.ts
================================================
/* eslint-disable @typescript-eslint/no-explicit-any */
import { RPCBase } from "../rpcBase";

export type Table<U> = {
  id: number;
  params: { table: U };
  result: boolean;
};

export type Key = keyof Config;

export type Config = {
  MediaEncrypt: {
    PrivateMediaEncrypt: {
      KeyFrameEncrypt: {
        Enable: boolean;
        VKUpdateTime: number;
      };
    };
    RTSPOverTls: {
      Enable: boolean;
    };
  };
  AutoMaintain: unknown;
  Network: unknown;
  Mobile: unknown;
  PPPoE: unknown;
  IPv6: unknown;
  ARP: unknown;
  Ping: unknown;
  DVRIP: unknown;
  Web: unknown;
  RTSP: {
    Enable: boolean;
    Port: number;
    RTP: {
      EndPort: number;
      StartPort: number;
    };
  };
  Https: unknown;
  UserGlobal: unknown;
  DDNS: unknown;
  AccessFilter: unknown;
  Email: {
    Address: string;
    Anonymous: boolean;
    AttachEnable: boolean;
    Authentication: boolean;
    CustomTitle: Array<unknown>;
    Enable: boolean;
    HealthReport: {
      Enable: boolean;
      Interval: number;
    };
    OnlyAttachment: boolean;
    Password: string;
    Port: number;
    Receivers: Array<string>;
    SendAddress: string;
    SendInterv: number;
    SslEnable: boolean;
    Title: string;
    TlsEnable: boolean;
    UserName: string;
  };
  UPnP: unknown;
  SNMP: unknown;
  Bonjour: {
    Enable: boolean;
    Name: string;
  };
  Multicast: unknown;
  Wire802_1X: unknown;
  Qos: unknown;
  WMM: unknown;
  WLan: unknown;
  Wireless: unknown;
  AlarmServer: unknown;
  MacConflict: unknown;
  StorageNotExist: {
    Enable: boolean;
    EventHandler: {
      AlarmOut: number;
      AlarmOutChannels: Array<number>;
      AlarmOutEnable: boolean;
      AlarmOutLatch: number;
      BeepEnable: boolean;
      Dejitter: number;
      Delay: number;
      ExAlarmOut: number;
      ExAlarmOutChannels: Array<number>;
      ExAlarmOutEnable: boolean;
      LogEnable: boolean;
      MailEnable: boolean;
      Matrix: number;
      MatrixChannels: Array<number>;
      MatrixEnable: boolean;
      MessageEnable: boolean;
      PtzLink: Array<[string, number]>;
      PtzLinkEnable: boolean;
      Record: number;
      RecordChannels: Array<number>;
      RecordEnable: boolean;
      RecordLatch: number;
      Snapshot: number;
      SnapshotChannels: Array<number>;
      SnapshotEnable: boolean;
      TimeSection: Array<Array<string>>;
      TipEnable: boolean;
      Tour: number;
      TourChannels: Array<number>;
      TourEnable: boolean;
      VoiceEnable: boolean;
    };
  };
  StorageLowSpace: unknown;
  StorageFailure: unknown;
  NetAbort: unknown;
  IPConflict: unknown;
  LoginFailureAlarm: unknown;
  Alarm: unknown;
  RemoteCtrl: unknown;
  ExAlarm: unknown;
  ArmMode: unknown;
  AlarmOut: unknown;
  Encode: Array<{
    ExtraFormat: Array<{
      Audio: {
        Bitrate?: number;
        Channels?: Array<number>;
        Compression: string;
        Depth?: number;
        Frequency?: number;
        Pack?: string;
      };
      AudioEnable: boolean;
      Video: {
        BitRate: number;
        BitRateControl: string;
        Compression: string;
        CustomResolutionName?: string;
        FPS?: number;
        GOP?: number;
        Height: number;
        Pack?: string;
        Priority?: number;
        Profile: string;
        Quality?: number;
        QualityRange?: number;
        SVCTLayer?: number;
        Width: number;
      };
      VideoEnable: boolean;
    }>;
    MainFormat: Array<{
      Audio: {
        Bitrate: number;
        Channels: Array<number>;
        Compression: string;
        Depth: number;
        Frequency: number;
        Mode: number;
        Pack: string;
      };
      AudioEnable: boolean;
      Video: {
        BitRate: number;
        BitRateControl: string;
        Compression: string;
        CustomResolutionName: string;
        FPS: number;
        GOP: number;
        Height: number;
        Pack: string;
        Priority: number;
        Profile: string;
        Quality: number;
        QualityRange: number;
        SVCTLayer: number;
        SvacSVCLayer?: {
          SpaceDomainSVCLayer: number;
          TimeDomainSVCLayer: number;
        };
        Width: number;
      };
      VideoEnable: boolean;
    }>;
    SnapFormat: Array<{
      Audio: {
        Bitrate: number;
        Compression: string;
        Depth: number;
        Frequency: number;
        Pack: string;
      };
      AudioEnable: boolean;
      Video: {
        BitRate: number;
        BitRateControl: string;
        Compression: string;
        CustomResolutionName: string;
        FPS: number;
        GOP: number;
        Height: number;
        Pack: string;
        Priority: number;
        Profile: string;
        Quality: number;
        QualityRange: number;
        SVCTLayer: number;
        Width: number;
      };
      VideoEnable: boolean;
    }>;
  }>;
  VideoWaterMark: unknown;
  AudioInputVolume: unknown;
  AudioOutputVolume: unknown;
  AudioInDenoise: unknown;
  AudioInput: Array<{
    AudioSource: "Mic" | string;
  }>;
  VideoWidget: unknown;
  ChannelTitle: unknown;
  VideoWidgetNumberStat: unknown;
  VideoInOptions: unknown;
  VideoColor: unknown;
  VideoInPreviewOptions: unknown;
  VideoInDefog: unknown;
  VideoImageControl: Array<{
    Flip: boolean;
    Freeze: boolean;
    Mirror: boolean;
    Rotate90: number;
    Stable: number;
  }>;
  VideoInSharpness: unknown;
  VideoInExposure: unknown;
  VideoInDenoise: unknown;
  VideoInIRExposure: unknown;
  VideoInBacklight: unknown;
  VideoInWhiteBalance: unknown;
  VideoInDayNight: unknown;
  VideoInMode: Array<{
    Config: Array<number>;
    Mode: number;
    TimeSection: Array<Array<string>>;
  }>;
  MotionDetect: unknown;
  BlindDetect: unknown;
  UnFocusDetect: unknown;
  AudioDetect: unknown;
  LossDetect: unknown;
  MovedDetect: unknown;
  VideoAnalyseRule: unknown;
  VideoAnalyseGlobal: unknown;
  VideoAnalyseModule: unknown;
  TrafficSnapshot: unknown;
  Holiday: unknown;
  Record: unknown;
  Snap: unknown;
  RecordStoragePoint: unknown;
  MediaGlobal: unknown;
  RecordMode: unknown;
  StorageGroup: unknown;
  NAS: unknown;
  StorageGlobal: unknown;
  Ptz: unknown;
  General: unknown;
  Locales: unknown;
  NTP: {
    Address: string;
    Enable: boolean;
    Port: number;
    TimeZone: number;
    TimeZoneDesc: string;
    UpdatePeriod: number;
  };
  VideoEncodeROI: unknown;
  VideoInFocus: unknown;
  VideoInZoom: unknown;
  VideoInColor: unknown;
  NetAlarm: unknown;
  ExAlarmOut: unknown;
  Sound: unknown;
  SmartEncode: Array<{ Enable: boolean }>;
  Comm: unknown;
  Lighting: unknown;
  VideoOut: unknown;
  DeviceInfo: unknown;
  EmergencyRecordForPull: unknown;
  EncodeAuth: unknown;
  EncodeEncrypt: Array<{
    ExtraFormat: Array<{
      Audio: {
        Bitrate?: number;
        Channels?: Array<number>;
        Compression: string;
        Depth?: number;
        Frequency?: number;
        Pack?: string;
      };
      AudioEnable: boolean;
      Video: {
        BitRate: number;
        BitRateControl: string;
        Compression: string;
        CustomResolutionName?: string;
        FPS?: number;
        GOP?: number;
        Height: number;
        Pack?: string;
        Priority?: number;
        Profile: string;
        Quality?: number;
        QualityRange?: number;
        SVCTLayer?: number;
        Width: number;
      };
      VideoEnable: boolean;
    }>;
    MainFormat: Array<{
      Audio: {
        Bitrate: number;
        Channels: Array<number>;
        Compression: string;
        Depth: number;
        Frequency: number;
        Mode: number;
        Pack: string;
      };
      AudioEnable: boolean;
      Video: {
        BitRate: number;
        BitRateControl: string;
        Compression: string;
        CustomResolutionName: string;
        FPS: number;
        GOP: number;
        Height: number;
        Pack: string;
        Priority: number;
        Profile: string;
        Quality: number;
        QualityRange: number;
        SVCTLayer: number;
        SvacSVCLayer?: {
          SpaceDomainSVCLayer: number;
          TimeDomainSVCLayer: number;
        };
        Width: number;
      };
      VideoEnable: boolean;
    }>;
    SnapFormat: Array<{
      Audio: {
        Bitrate: number;
        Compression: string;
        Depth: number;
        Frequency: number;
        Pack: string;
      };
      AudioEnable: boolean;
      Video: {
        BitRate: number;
        BitRateControl: string;
        Compression: string;
        CustomResolutionName: string;
        FPS: number;
        GOP: number;
        Height: number;
        Pack: string;
        Priority: number;
        Profile: string;
        Quality: number;
        QualityRange: number;
        SVCTLayer: number;
        Width: number;
      };
      VideoEnable: boolean;
    }>;
  }>;
  IntelliTrackScene: unknown;
  Language: unknown;
  MediaFileReaderGlobal: unknown;
  NetAccessPriority: unknown;
  PrivacyMasking: unknown;
  StorageQuota: unknown;
  Talkback: unknown;
  TwoRefEncode: unknown;
  VideoInFaceAutoExposure: unknown;
  VideoStandard: "NTSC" | "PAL" | string;
  WorkGroupMode: unknown;
  OSDSysAbnormal: unknown;
  T2UServer: unknown;
  VideoWidget2: unknown;
};

export function ConfigManager(this: RPCBase) {
  function parseArray(
    nameOrArray: string | string[],
    channelOrArray?: number | number[],
    onlyLocal?: boolean
  ) {
    void 0 == onlyLocal && (onlyLocal = !1);
    let obj: any = {};
    return (
      Array.isArray(nameOrArray)
        ? ((obj = []),
          nameOrArray.forEach((name, index) => {
            const g: any = { name: name };
            Array.isArray(channelOrArray)
              ? ((g.channel = channelOrArray[index]), (g.onlyLocal = onlyLocal))
              : typeof channelOrArray == "number" &&
                ((g.channel = channelOrArray), (g.onlyLocal = onlyLocal)),
              obj.push(g);
          }))
        : Array.isArray(channelOrArray)
        ? ((obj = []),
          channelOrArray.forEach((channel) => {
            obj.push({
              name: nameOrArray,
              channel: channel,
              onlyLocal: onlyLocal,
            });
          }))
        : ((obj = { name: nameOrArray }), typeof channelOrArray == "number") &&
          ((obj.channel = channelOrArray), (obj.onlyLocal = onlyLocal)),
      obj
    );
  }

  function parseTableArray(
    nameOrArray: string | string[],
    table: any,
    channel?: number,
    option?: any
  ) {
    let f: any = {};
    return (
      Array.isArray(nameOrArray)
        ? ((f = []),
          nameOrArray.forEach((name, index) => {
            const h: any = {
              name: name,
              table: table[index],
              options: option || [],
            };
            Array.isArray(channel)
              ? (h.channel = channel[index])
              : typeof channel == "number" && (h.channel = channel),
              f.push(h);
          }))
        : Array.isArray(channel)
        ? ((f = []),
          channel.forEach((d, index) => {
            f.push({
              name: nameOrArray,
              table: table[index],
              channel: d,
              options: option || [],
            });
          }))
        : ((f = { name: nameOrArray, table: table, options: option || [] }),
          typeof channel == "number" && (f.channel = channel)),
      f
    );
  }

  type WrapTableResponse<Names extends [...unknown[]]> = Names extends [
    infer Head,
    ...infer Tail
  ]
    ? [
        Table<Head extends Key ? Config[Head] : unknown>,
        ...WrapTableResponse<Tail>
      ]
    : [];

  const getConfig: // Get multiple configs on a channel
  (<Names extends Key[]>(
    nameArray: [...Names],
    channel?: number,
    onlyLocal?: boolean
  ) => Promise<WrapTableResponse<Names>>) &
    // Get a config on a channel
    (<Name extends Key>(
      name: Name,
      channel?: number,
      onlyLocal?: boolean
    ) => Promise<Config[Name]>) &
    // Get a config on multiple channels
    (<Name extends Key>(
      name: Name,
      channelArray: number[],
      onlyLocal?: boolean
    ) => Promise<Array<Table<Config[Name]>>>) = <T>(
    nameOrArray: string | string[],
    channelOrArray?: number | number[],
    onlyLocal?: boolean
  ): Promise<T> => {
    return this.send<{ table: any }>(
      "configManager.getConfig",
      parseArray(nameOrArray, channelOrArray, onlyLocal)
    ).then(function (b) {
      return Array.isArray(nameOrArray) || Array.isArray(channelOrArray)
        ? b.params
        : b.params.table;
    });
  };

  const getDefault: // Get default multiple configs on a channel
  (<Names extends Key[]>(
    nameArray: [...Names],
    channel?: number,
    _?: null,
    secure?: boolean
  ) => Promise<WrapTableResponse<Names>>) &
    // Get a default config on a channel
    (<Name extends Key>(
      name: Name,
      channel?: number,
      _?: null,
      secure?: boolean
    ) => Promise<Config[Name]>) &
    // Get a default config on multiple channels
    (<Name extends Key>(
      name: Name,
      channelArray: number[],
      _?: null,
      secure?: boolean
    ) => Promise<Array<Table<Config[Name]>>>) = <T>(
    nameOrArray: string | string[],
    channelOrArray?: number | number[],
    _?: null,
    secure?: boolean
  ): Promise<T> => {
    secure &&
      (() => {
        throw "secure send not implemented";
      })();
    return this.send<{ table: any }>(
      "configManager.getDefault",
      parseArray(nameOrArray, channelOrArray)
    ).then(function (b) {
      return Array.isArray(nameOrArray) || Array.isArray(channelOrArray)
        ? b.params
        : b.params.table;
    });
  };

  type WrapTable<Names extends [...unknown[]]> = Names extends [
    infer Head,
    ...infer Tail
  ]
    ? [Head extends Key ? Config[Head] : unknown, ...WrapTable<Tail>]
    : [];

  type UpdateResponse = { options: unknown };

  const setConfig: // Set multiple configs on a channel
  (<Names extends Key[]>(
    nameArray: [...Names],
    table: WrapTable<Names>,
    channel?: number,
    onlyLocal?: boolean
  ) => Promise<unknown>) &
    // Set a config on a channel
    (<Name extends Key>(
      name: Name,
      table: Config[Name],
      channel?: number,
      onlyLocal?: boolean
    ) => Promise<unknown>) = <T>(
    nameOrArray: string | string[],
    table: T,
    channel?: number,
    onlyLocal?: boolean
  ) => {
    return this.send<UpdateResponse>(
      "configManager.setConfig",
      parseTableArray(nameOrArray, table, channel, onlyLocal)
    ).then(function (c) {
      return Array.isArray(nameOrArray) ? c.params : c.params.options;
    });
  };

  const restore: (names: Key[], options?: any) => Promise<unknown> = (
    names: string[],
    options?: any
  ) => {
    return this.send<UpdateResponse>("configManager.restore", {
      names: names,
      options: options || [],
    }).then(function (a) {
      return a.params.options;
    });
  };

  const restoreExcept: (names: Key[], options?: any) => Promise<unknown> = (
    names: string[],
    options?: any
  ) => {
    return this.send<UpdateResponse>("configManager.restoreExcept", {
      names: names,
      options: options,
    }).then(function (a) {
      return a.params.options;
    });
  };

  return {
    /**
     * Get config by the given config name or names.
     */
    getConfig,
    /**
     * Set config by the given config name or names.
     */
    setConfig,
    /**
     * Get default config by the given config name or names.
     */
    getDefault,
    setTemporaryConfig: (
      nameOrArray: string | string[],
      table: any,
      channel: number,
      onlyLocal: boolean | number
    ) => {
      return this.send<UpdateResponse>(
        "configManager.setTemporaryConfig",
        parseTableArray(nameOrArray, table, channel, onlyLocal)
      ).then(function (c) {
        return Array.isArray(nameOrArray) ? c.params : c.params.options;
      });
    },
    restoreTemporaryConfig: (
      arrayOrName: string[] | string,
      channel: number
    ) => {
      return this.send<UpdateResponse>(
        "configManager.restoreTemporaryConfig",
        parseArray(arrayOrName, channel)
      ).then(function (b) {
        return Array.isArray(arrayOrName) ? b.params : b.params.options;
      });
    },
    /**
     * Restore configs by the given config names.
     */
    restore,
    /**
     * Restore everything EXCEPT the given config names. BE CAREFUL AS THIS WIPES EVERY CONFIG EXCEPT THE ONES YOU SPECIFY.
     */
    restoreExcept,
    deleteFile: () => {
      return this.send("configManager.deleteFile");
    },
    setChnlConfig: (
      name: string,
      table: any,
      channel: number,
      options: any
    ) => {
      return (
        (options = options || []),
        this.send<UpdateResponse>("configManager.setChannelConfig", {
          name: name,
          table: table,
          channels: channel,
          options: options,
        }).then(function (a) {
          return a.params.options || [];
        })
      );
    },
    saveFile: () => {
      return this.send("configManager.saveFile");
    },
  };
}



================================================
FILE: lib/rpc/DdnsClient.ts
================================================
import { RPCBase } from "../rpcBase";

export function DdnsClient(this: RPCBase) {
  return {
    getStatus: () => {
      return this.send<{
        status: {
          Protocol: string;
          Value: string;
          ConIp?: string;
          Status: number;
        }[];
      }>("ddnsClient.getStatus").then(function (a) {
        return a.params.status;
      });
    },
    getDomainNames: (ddnsInfo: unknown) => {
      return this.send<{ names: unknown }>("ddnsClient.getDomainNames", {
        ddnsInfo: ddnsInfo,
      }).then(function (a) {
        return a.params.names;
      });
    },
    testHostName: (
      Protocol: unknown,
      Address: unknown,
      Port: unknown,
      HostName: unknown,
      UserName: unknown,
      Password: unknown
    ) => {
      return this.send<{ Detail: unknown }>("ddnsClient.testHostName", {
        Protocol: Protocol,
        Address: Address,
        Port: Port,
        HostName: HostName,
        UserName: UserName,
        Password: Password,
      }).then(function (a) {
        return a.params.Detail;
      });
    },
  };
}



================================================
FILE: lib/rpc/DevAudioDetect.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevAudioDetect(this: RPCBase) {
  const instance = this.sendSetup("devAudioDetect.factory.instance");
  return {
    instance,
    getCaps: (channel?: string) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{
          caps: {
            VolumeDetect: boolean;
            AnomalyDetect: boolean;
            MutationDetect: boolean;
            InfantCryDetect?: boolean;
            AnomalySensitiveRange: [number, number];
            MutationThreoldRange: [number, number];
          };
        }>("devAudioDetect.getCaps", void 0, { object: a.result }).then((a) => {
          return a.params.caps;
        });
      });
    },
    detachDetectData: (channel?: number, proc?: string) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "devAudioDetect.detachDetectData",
          { proc: proc },
          { object: a.result }
        );
      });
    },
    attachDetectData: (channel?: number, proc?: string) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "devAudioDetect.attachDetectData",
          { proc: proc },
          { object: a.result }
        );
      });
    },
  };
}



================================================
FILE: lib/rpc/DevAudioEncode.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevAudioEncode(this: RPCBase) {
  const instance = this.sendSetup("devAudioEncode.factory.instance");
  return {
    instance,
    getFormatCaps: (stream?: string, channel?: number) => {
      return instance({ channel: channel || 0, stream: stream || "Main" }).then(
        (a) => {
          return this.send<{
            formats: Array<{
              Compression: string;
              Depth: number;
              Frequency: number;
            }>;
          }>("devAudioEncode.getFormatCaps", void 0, {
            object: a.result,
          }).then(function (a) {
            return a.params.formats;
          });
        }
      );
    },
    getDigitalFormatCaps: (stream?: string, channel?: number) => {
      return instance({ channel: channel || 0, stream: stream || "Main" }).then(
        (a) => {
          return this.send<{
            formats: Array<{
              Compression: string;
              Depth: number;
              Frequency: number;
            } | null>;
          }>("devAudioEncode.getDigitalFormatCaps", void 0, {
            object: a.result,
          }).then(function (a) {
            return a.params.formats;
          });
        }
      );
    },
    getCaps: (stream?: string, channel?: number) => {
      return instance({ channel: channel || 0, stream: stream || "Main" }).then(
        (a) => {
          return this.send<{
            caps: {
              SupportLevel: boolean;
            };
          }>("devAudioEncode.getCaps", void 0, { object: a.result }).then(
            function (a) {
              return a.params.caps;
            }
          );
        }
      );
    },
  };
}



================================================
FILE: lib/rpc/DevAudioInput.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevAudioInput(this: RPCBase) {
  const instance = this.sendSetup("devAudioInput.factory.instance");
  return {
    instance,
    getCollect: () => {
      return this.send<{ channels: number[] }>(
        "devAudioInput.factory.getCollect"
      ).then(function (a) {
        return a.params.channels || 0;
      });
    },
    getCaps: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{
          caps: {
            BTInput?: number;
            DigitalAudio?: number;
            LineIn?: number;
            Mic?: number;
            realMic?: number;
          };
        }>("devAudioInput.getCaps", void 0, { object: a.result }).then(
          function (a) {
            return a.params.caps;
          }
        );
      });
    },
  };
}



================================================
FILE: lib/rpc/DevAudioOutput.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevAudioOutput(this: RPCBase) {
  const instance = this.sendSetup("devAudioOutput.factory.instance");
  return {
    instance,
    getCollect: () => {
      return this.send<{ channels: number[] }>(
        "devAudioOutput.factory.getCollect"
      ).then(function (a) {
        return a.params.channels || 0;
      });
    },
    getCaps: (channel?: number) => {
      return this.send<{ caps: unknown }>("devAudioOutput.getCaps", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params.caps;
      });
    },
  };
}



================================================
FILE: lib/rpc/DevFlashLampManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevFlashLampManager(this: RPCBase) {
  const instance = this.sendSetup("devFlashLampManager.instance");
  return {
    instance,
    getCaps: () => {
      return instance().then((a) => {
        return this.send<{ caps: unknown }>(
          "devFlashLampManager.getCaps",
          null,
          { object: a.result }
        ).then(function (a) {
          return a.params.caps;
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/DevInit.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevInit(this: RPCBase) {
  return {
    getStatus: () => {
      return this.sendRPC(
        this.rpc("DevInit.getStatus", null),
        "/OutsideCmd"
      ).then(function (a) {
        return a;
      });
    },
    account: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.sendRPC(
        this.rpc("DevInit.account", {
          salt: salt,
          cipher: cipher,
          content: content,
        }),
        "/OutsideCmd"
      ).then(function (a) {
        return a;
      });
    },
    access: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.sendRPC(
        this.rpc("DevInit.access", {
          salt: salt,
          cipher: cipher,
          content: content,
        }),
        "/OutsideCmd"
      ).then(function (a) {
        return a;
      });
    },
    getCurrentTime: () => {
      return this.sendRPC(
        this.rpc("DevInit.getCurrentTime", {}),
        "/OutsideCmd"
      ).then(function (a) {
        return a;
      });
    },
    setCurrentTime: (time: unknown, tolerance: unknown) => {
      return this.sendRPC(
        this.rpc("DevInit.setCurrentTime", {
          time: time,
          tolerance: tolerance,
        }),
        "/OutsideCmd"
      ).then(function (a) {
        return a;
      });
    },
    setLocalityConfig: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.sendRPC(
        this.rpc("DevInit.setLocalityConfig", {
          salt: salt,
          cipher: cipher,
          content: content,
        }),
        "/OutsideCmd"
      ).then(function (a) {
        return a;
      });
    },
    getDevCaps: () => {
      return this.sendRPC(this.rpc("DevInit.getDevCaps"), "/OutsideCmd").then(
        function (a) {
          return a && a.params;
        }
      );
    },
  };
}



================================================
FILE: lib/rpc/DevIntelliTracker.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevIntelliTracker(this: RPCBase) {
  const instance = this.sendSetup("devIntelliTracker.factory.instance");
  return {
    instance,
    getLockLeft: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ time: unknown }>(
          "devIntelliTracker.getLockLeft",
          void 0,
          {
            object: a.result,
          }
        ).then(function (a) {
          return a.params.time;
        });
      });
    },
    setLockDuration: (time: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "devIntelliTracker.setLockDuration",
          { time: time },
          { object: b.result }
        );
      });
    },
    start: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("devIntelliTracker.start", void 0, {
          object: a.result,
        });
      });
    },
    stop: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("devIntelliTracker.stop", void 0, {
          object: a.result,
        });
      });
    },
    trackObject: (object: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "devIntelliTracker.trackObject",
          { object: object },
          { object: a.result }
        );
      });
    },
    gotoScene: (scene: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "devIntelliTracker.gotoScene",
          { scene: scene },
          { object: a.result }
        );
      });
    },
    markScene: (scene: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "devIntelliTracker.markScene",
          { scene: scene },
          { object: a.result }
        );
      });
    },
    markSceneMaxZoom: (scene: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "devIntelliTracker.markSceneMaxZoom",
          { scene: scene },
          { object: a.result }
        );
      });
    },
    markSceneLimit: (scene: unknown, type: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "devIntelliTracker.markSceneLimit",
          { scene: scene, type: type },
          { object: a.result }
        );
      });
    },
    gotoSceneLimit: (scene: unknown, type: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "devIntelliTracker.gotoSceneLimit",
          { scene: scene, type: type },
          { object: a.result }
        );
      });
    },
    getCaps: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ caps: unknown }>("devIntelliTracker.getCaps", null, {
          object: a.result,
        }).then(function (a) {
          return a.params.caps;
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/DevStorage.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevStorage(this: RPCBase) {
  const instance = this.sendSetup("devStorage.factory.instance");
  return {
    instance,
    getSmartValue: (name: unknown) => {
      return instance({ name: name }).then((a) => {
        return this.send<{ values: unknown }>(
          "devStorage.getSmartValue",
          null,
          { object: a.result }
        ).then(function (a) {
          return a.params.values;
        });
      });
    },
    formatPatition: (name: unknown, part?: string, fs?: string) => {
      return instance({ name: name }).then((a) => {
        return this.send(
          "devStorage.formatPatition",
          { part: part || "", fs: fs || "" },
          { object: a.result }
        );
      });
    },
    eject: (name: unknown) => {
      return instance({ name: name }).then((a) => {
        return this.send("devStorage.eject", void 0, { object: a.result });
      });
    },
    getDeviceInfo: (name: unknown) => {
      return instance({ name: name }).then((a) => {
        return this.send<{ device: unknown }>(
          "devStorage.getDeviceInfo",
          void 0,
          { object: a.result }
        ).then(function (a) {
          return a.params.device;
        });
      });
    },
    setAsHotSpare: (
      name1: unknown,
      enable: unknown,
      global: unknown,
      name2?: string
    ) => {
      return instance({ name: name1 }).then((a) => {
        return this.send(
          "devStorage.setAsHotSpare",
          { enable: enable, global: global, name: name2 || "" },
          { object: a.result }
        );
      });
    },
    releaseDevice: (name: unknown) => {
      return instance({ name: name }).then((a) => {
        return this.send<{ values: unknown }>(
          "devStorage.releaseDevice",
          null,
          { object: a.result }
        ).then(function (a) {
          return a.params.values;
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/DevVariableCapsManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevVariableCapsManager(this: RPCBase) {
  return {
    getFuncTypeList: () => {
      return this.send("DevVariableCapsManager.getFuncTypeList").then(function (
        a
      ) {
        return a.params;
      });
    },
    checkStart: (
      FuncType: unknown,
      Table: unknown,
      Channel?: number,
      PtzPresetID?: number
    ) => {
      return this.send("DevVariableCapsManager.checkStart", {
        FuncType: FuncType,
        Table: Table,
        Channel: Channel || 0,
        PtzPresetID: PtzPresetID || 0,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/DevVideoAnalyse.ts
================================================
import { RPCBase } from "../rpcBase";

export type GetCapsResponse = {
  CalibrateBoxs: Array<number>;
  ComplexSizeFilter: boolean;
  DefaultSnapMosaic2: boolean;
  FilterMask: number;
  IntelliTracker: {
    Support: boolean;
  };
  MaxCelibateAreas: number;
  MaxExcludeRegions: number;
  MaxInternalOptions: number;
  MaxModules: number;
  MaxPointOfLine: number;
  MaxPointOfRegion: number;
  MaxRules: number;
  MaxStaffs: number;
  SpecifiedObjectFilter: boolean;
  SupportedComp: Array<Array<string>>;
  SupportedObjectTypes: Array<string>;
  SupportedScene: Array<string>;
  SupportedScenes: {
    FaceDetection: {
      MaxLanes: number;
      MaxRules: number;
      SupportSnapMode: number;
      SupportedCalibrateParams: {
        Groud: {
          HorizontalStaffs: Array<number>;
          VerticalStaffs: Array<number>;
        };
        MaxCelibateAreas: number;
      };
      SupportedModuleParams: {
        Accuracy: boolean;
        AlgorithmIndex: boolean;
        Backlight: boolean;
        ContourAssistantTrack: boolean;
        DetectBalance: boolean;
        DetectRegion: boolean;
        Disturbance: boolean;
        ExcludeRegion: boolean;
        Highlight: boolean;
        MovingStep: boolean;
        ScalingFactor: boolean;
        SizeFilter: {
          MeasureMode: {
            CalibratedPixel: boolean;
            Metric: boolean;
            Pixel: boolean;
          };
        };
        Snapshot: boolean;
        ThresholdEdge: boolean;
        ThresholdUV: boolean;
        ThresholdY: boolean;
      };
      SupportedObjectTypes: unknown;
      SupportedRules: {
        FaceDetection: {
          CutoutCustomScale: {
            BodyHeightTimesRange: Array<number>;
            FaceHeightTimesRange: Array<number>;
            ImageWidthTimesRange: Array<number>;
          };
          CutoutPolicy: Array<string>;
          FaceFilterSupport: boolean;
          FeatureList: Array<string>;
          FeatureSupport: number;
          SnapPolicy: Array<string>;
          SupportedHumanFaceTypes: unknown;
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
      };
      SupportedSceneParams: {
        CameraAspect: boolean;
        Dejitter: boolean;
        HiddenDetail: boolean;
        Jitter: boolean;
      };
    };
    HeatMap: {
      MaxLanes: number;
      MaxRules: number;
      SupportSnapMode: number;
      SupportedCalibrateParams: {
        Groud: {
          HorizontalStaffs: Array<number>;
          VerticalStaffs: Array<number>;
        };
        MaxCelibateAreas: number;
      };
      SupportedModuleParams: {
        Accuracy: boolean;
        AlgorithmIndex: boolean;
        AntiDisturbance: boolean;
        Backlight: boolean;
        ContourAssistantTrack: boolean;
        DetectBalance: boolean;
        DetectRegion: boolean;
        Disturbance: boolean;
        ExcludeRegion: boolean;
        Highlight: boolean;
        MovingStep: boolean;
        ScalingFactor: boolean;
        Shadow: boolean;
        SizeFilter: {
          MeasureMode: {
            CalibratedPixel: boolean;
            Metric: boolean;
            Pixel: boolean;
          };
        };
        Snapshot: boolean;
        ThresholdEdge: boolean;
        ThresholdUV: boolean;
        ThresholdY: boolean;
      };
      SupportedObjectTypes: unknown;
      SupportedRules: {
        HeatMap: {
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
      };
      SupportedSceneParams: {
        CameraAspect: boolean;
        Dejitter: boolean;
        HiddenDetail: boolean;
        Jitter: boolean;
      };
    };
    Normal: {
      MaxLanes: number;
      MaxRules: number;
      SupportSnapMode: number;
      SupportedCalibrateParams: {
        Groud: {
          HorizontalStaffs: Array<number>;
          VerticalStaffs: Array<number>;
        };
        MaxCelibateAreas: number;
      };
      SupportedModuleParams: {
        Accuracy: boolean;
        AlgorithmIndex: boolean;
        AntiDisturbance: boolean;
        Backlight: boolean;
        ContourAssistantTrack: boolean;
        DetectBalance: boolean;
        DetectRegion: boolean;
        Disturbance: boolean;
        ExcludeRegion: boolean;
        Highlight: boolean;
        MovingStep: boolean;
        ScalingFactor: boolean;
        Shadow: boolean;
        SizeFilter: {
          MeasureMode: {
            CalibratedPixel: boolean;
            Metric: boolean;
            Pixel: boolean;
          };
        };
        Snapshot: boolean;
        ThresholdEdge: boolean;
        ThresholdUV: boolean;
        ThresholdY: boolean;
      };
      SupportedObjectTypes: unknown;
      SupportedRules: {
        CrossLineDetection: {
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
        CrossRegionDetection: {
          SupportedActions: Array<string>;
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
        LeftDetection: {
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
        MoveDetection: {
          SupportedDetectTypes: Array<string>;
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
        ParkingDetection: {
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
        RioterDetection: {
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
        TakenAwayDetection: {
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
        WanderDetection: {
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
      };
      SupportedSceneParams: {
        CameraAspect: boolean;
        Dejitter: boolean;
        HiddenDetail: boolean;
        Jitter: boolean;
        SupportDistLimit: boolean;
        SupportOverlapPercent: boolean;
        SupportTimeLimit: boolean;
      };
    };
    NumberStat: {
      CameraType: number;
      MaxLanes: number;
      MaxRules: number;
      SupportSnapMode: number;
      SupportedCalibrateParams: {
        Groud: {
          HorizontalStaffs: Array<number>;
          VerticalStaffs: Array<number>;
        };
        MaxCelibateAreas: number;
      };
      SupportedModuleParams: {
        Accuracy: boolean;
        AlgorithmIndex: boolean;
        Backlight: boolean;
        ContourAssistantTrack: boolean;
        DetectBalance: boolean;
        DetectRegion: boolean;
        Disturbance: boolean;
        ExcludeRegion: boolean;
        Highlight: boolean;
        MovingStep: boolean;
        ScalingFactor: boolean;
        SizeFilter: {
          MaxSize: Array<number>;
          MeasureMode: {
            CalibratedPixel: boolean;
            Metric: boolean;
            Pixel: boolean;
          };
          MinSize: Array<number>;
        };
        Snapshot: boolean;
        ThresholdEdge: boolean;
        ThresholdUV: boolean;
        ThresholdY: boolean;
      };
      SupportedObjectTypes: unknown;
      SupportedRules: {
        ManNumDetection: {
          DetectType: Array<number>;
          MaxRules: number;
          SupportLocalDataStore: boolean;
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
        NumberStat: {
          MaxRules: number;
          SupportLocalDataStore: boolean;
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
        QueueDetection: {
          MaxRules: number;
          SupportLocalDataStore: boolean;
          SupportedObjectTypes: Array<string>;
          TriggerPosition: boolean;
          TriggerTrack: boolean;
        };
      };
      SupportedSceneParams: {
        CameraAspect: boolean;
        Dejitter: boolean;
        HiddenDetail: boolean;
        Jitter: boolean;
      };
    };
  };
  SupportedVideoChannelType: unknown;
};

export function DevVideoAnalyse(this: RPCBase) {
  const instance = this.sendSetup("devVideoAnalyse.factory.instance");
  return {
    instance,
    getCaps: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ caps: GetCapsResponse }>(
          "devVideoAnalyse.getCaps",
          void 0,
          { object: a.result }
        ).then(function (a) {
          return a.params.caps;
        });
      });
    },
    getTemplateRule: (rule: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "devVideoAnalyse.getTemplateRule",
          { rule: rule },
          { object: b.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
    testCalibrateWithScreenPoints: (
      type: unknown,
      start: unknown,
      end: unknown,
      channel?: number
    ) => {
      return instance({ channel: channel || 0 }).then((d) => {
        return this.send<{ length: unknown }>(
          "devVideoAnalyse.testCalibrateWithScreenPoints",
          { type: type, start: start, end: end },
          { object: d.result }
        ).then(function (a) {
          return a.params.length;
        });
      });
    },
    setAnalyseObject: (rule: { channel?: number; object: unknown }) => {
      return instance({ channel: rule.channel || 0 }).then(() => {
        return this.send(
          "devVideoAnalyse.setAnalyseObject",
          { channel: rule.channel, object: rule.object },
          void 0
        ).then(function (a) {
          return a;
        });
      });
    },
    getWaterLevelCalibrateInfo: (
      PresetID: number,
      RuleID?: number,
      channel?: number
    ) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "devVideoAnalyse.getWaterLevelCalibrateInfo",
          { PresetID: PresetID, RuleID: RuleID || 0 },
          { object: c.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
    setWaterLevelCalibrateInfo: (
      calibration: {
        PresetID: number;
        RuleID: number;
        Type: unknown;
        CalibratePoint: unknown;
      },
      channel?: number
    ) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "devVideoAnalyse.setWaterLevelCalibrateInfo",
          {
            PresetID: calibration.PresetID,
            RuleID: calibration.RuleID,
            Type: calibration.Type,
            CalibratePoint: calibration.CalibratePoint,
          },
          { object: b.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/DevVideoDetect.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevVideoDetect(this: RPCBase) {
  const instance = this.sendSetup("devVideoDetect.factory.instance");
  return {
    instance,
    getCaps: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{
          caps: {
            DetectVersion: Array<string>;
            MotionColumns: number;
            MotionDetectWindow: number;
            MotionLinkPtzPattern: boolean;
            MotionLinkPtzPreset: boolean;
            MotionLinkPtzTour: boolean;
            MotionResult: boolean;
            MotionRows: number;
            SmartMotion: {
              SmartType: Array<string>;
              Support: boolean;
            };
            SupportBlind: boolean;
            SupportLoss: boolean;
            SupportMotion: boolean;
            SupportMovedDetect: boolean;
            UnFocusDetect: boolean;
          };
        }>("devVideoDetect.getCaps", void 0, { object: a.result }).then(
          function (a) {
            return a.params.caps;
          }
        );
      });
    },
    attachMotionData: (proc: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "devVideoDetect.attachMotionData",
          { proc: proc },
          { object: b.result }
        );
      });
    },
    detachMotionData: (proc: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "devVideoDetect.detachMotionData",
          { proc: proc },
          { object: b.result }
        );
      });
    },
  };
}



================================================
FILE: lib/rpc/DevVideoEncode.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevVideoEncode(this: RPCBase) {
  const instance = this.sendSetup("devVideoEncode.factory.instance");
  return {
    instance,
    getCaps: (stream?: string, channel?: number, group?: number) => {
      return instance({
        channel: channel || 0,
        group: group || 0,
        stream: stream || "Main",
      }).then((a) => {
        return this.send<{ caps: unknown }>("devVideoEncode.getCaps", void 0, {
          object: a.result,
        }).then(function (a) {
          return a.params.caps;
        });
      });
    },
    setIFrame: (stream?: string, channel?: number, group?: number) => {
      return instance({
        channel: channel || 0,
        group: group || 0,
        stream: stream || "Main",
      }).then((a) => {
        return this.send("devVideoEncode.setIFrame", void 0, {
          object: a.result,
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/DevVideoInput.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevVideoInput(this: RPCBase) {
  const instance = this.sendSetup("devVideoInput.factory.instance");
  return {
    instance,
    getCollect: () => {
      return this.send<{ channels: number }>(
        "devVideoInput.factory.getCollect"
      ).then(function (a) {
        return a.params.channels || 0;
      });
    },
    getCaps: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ caps: unknown }>("devVideoInput.getCaps", void 0, {
          object: a.result,
        }).then(function (a) {
          return a.params.caps;
        });
      });
    },
    getCapsEx: (channel?: number, Name?: string) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ caps: unknown }>(
          "devVideoInput.getCapsEx",
          { Name: Name || "All" },
          { object: a.result }
        ).then(function (a) {
          return a.params.caps;
        });
      });
    },
    getFocusStatus: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ status: unknown }>(
          "devVideoInput.getFocusStatus",
          void 0,
          {
            object: a.result,
          }
        ).then(function (a) {
          return a.params.status;
        });
      });
    },
    setCalibrateState: (State?: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "devVideoInput.setCalibrateState",
          { State: State },
          { object: b.result }
        );
      });
    },
    getVideoInStatus: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ status: unknown }>(
          "devVideoInput.getVideoInStatus",
          void 0,
          {
            object: a.result,
          }
        ).then(function (a) {
          return a.params.status;
        });
      });
    },
    autoFocus: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("devVideoInput.autoFocus", void 0, {
          object: a.result,
        });
      });
    },
    stopAutoFocus: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("devVideoInput.stopAutoFocus", void 0, {
          object: a.result,
        });
      });
    },
    focusRegion: (mode: unknown, rect: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "devVideoInput.focusRegion",
          { mode: mode, rect: rect },
          { object: c.result }
        );
      });
    },
    adjustFocus: (focus: unknown, zoom: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "devVideoInput.adjustFocus",
          { focus: focus, zoom: zoom },
          { object: c.result }
        );
      });
    },
    adjustFocusContinuously: (
      focus: number,
      zoom: number,
      channel?: number
    ) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "devVideoInput.adjustFocusContinuously",
          { focus: focus, zoom: zoom },
          { object: c.result }
        );
      });
    },
    exposureRegion: (rect: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "devVideoInput.exposureRegion",
          { rect: rect },
          { object: b.result }
        );
      });
    },
    adjustIris: (open?: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "devVideoInput.adjustIris",
          { open: open },
          { object: b.result }
        );
      });
    },
    getCalibrationCoordinate: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ Coordinate: unknown }>(
          "devVideoInput.getCalibrationCoordinate",
          void 0,
          {
            object: a.result,
          }
        ).then(function (a) {
          return a.params.Coordinate;
        });
      });
    },
    getImageRawBrightness: (Mode: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send<{ RawBrightness: unknown }>(
          "devVideoInput.getImageRawBrightness",
          { Mode: Mode },
          { object: b.result }
        ).then(function (a) {
          return a.params.RawBrightness;
        });
      });
    },
    getFishEyeWinInfo: (winIdSet: unknown) => {
      return this.send<{ winInfo: unknown }>(
        "devVideoInput.getFishEyeWinInfo",
        {
          winIdSet: winIdSet,
          channel: 0,
        }
      ).then(function (a) {
        return a.params.winInfo;
      });
    },
    setFishEyeEPtz: (
      winID: unknown,
      cmd: unknown,
      arg1: unknown,
      arg2: unknown,
      arg3: unknown,
      arg4: unknown,
      channel?: number
    ) => {
      return this.send("devVideoInput.setFishEyeEPtz", {
        winID: winID,
        cmd: cmd,
        arg1: arg1,
        arg2: arg2,
        arg3: arg3,
        arg4: arg4,
        channel: channel || 0,
      });
    },
    resetFocusOptions: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("devVideoInput.resetFocusOptions", void 0, {
          object: a.result,
        });
      });
    },
    cancelTestSyncPhaseBright: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("devVideoInput.cancelTestSyncPhaseBright", void 0, {
          object: a.result,
        });
      });
    },
    testSyncPhaseBright: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("devVideoInput.testSyncPhaseBright", void 0, {
          object: a.result,
        });
      });
    },
    getExternalSyncState: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ status: string }>(
          "devVideoInput.getExternalSyncState",
          void 0,
          {
            object: a.result,
          }
        ).then(function (a) {
          return a.params.status;
        });
      });
    },
    setVideoSource: (info: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "devVideoInput.setVideoSource",
          { info: info },
          { object: b.result }
        );
      });
    },
    getDenoiseInfo: (params: object | object[] | null, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send("devVideoInput.getDenoiseInfo", params, {
          object: b.result,
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/DevVideoOutput.ts
================================================
import { RPCBase } from "../rpcBase";

export function DevVideoOutput(this: RPCBase) {
  const instance = this.sendSetup("devVideoOutput.factory.instance");
  return {
    instance,
    getCollect: () => {
      return this.send<{ channels: unknown }>(
        "devVideoOutput.factory.getCollect"
      ).then(function (a) {
        return a.params.channels;
      });
    },
    getCaps: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ caps: unknown }>("devVideoOutput.getCaps", void 0, {
          object: a.result,
        }).then(function (a) {
          return a.params.caps;
        });
      });
    },
    enumModes: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ modeTable: unknown }>(
          "devVideoOutput.enumModes",
          void 0,
          { object: a.result }
        ).then(function (a) {
          return a.params.modeTable;
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/DigitalCertificate.ts
================================================
import { RPCBase } from "../rpcBase";

export function DigitalCertificate(this: RPCBase) {
  return {
    getCertReqInfo: (params?: object | object[] | null) => {
      return this.send("DigitalCertificate.getCertReqInfo", params).then(
        function (a) {
          return a.params;
        }
      );
    },
    importCert: (Type: unknown, Cert: unknown, options: object) => {
      return this.send("DigitalCertificate.importCert", {
        ...{ Type: Type, Cert: Cert },
        ...options,
      }); // NOTE: this.sendSec
    },
    getCertsInfo: (
      Offset: unknown,
      Count: unknown,
      DigitalCertificateType?: string
    ) => {
      return this.send("DigitalCertificate.getCertsInfo", {
        DigitalCertificateType: DigitalCertificateType || "GM",
        Offset: Offset,
        Count: Count,
      });
    },
    deleteCert: (CertSN: unknown, DigitalCertificateType?: string) => {
      return this.send("DigitalCertificate.deleteCert", {
        DigitalCertificateType: DigitalCertificateType || "GM",
        CertSN: CertSN,
      });
    },
    exportCert: (CertSN: unknown, DigitalCertificateType?: string) => {
      return this.send("DigitalCertificate.exportCert", {
        DigitalCertificateType: DigitalCertificateType || "GM",
        CertSN: CertSN,
      });
    },
    importCRL: (CRL: unknown, DigitalCertificateType?: string) => {
      return this.send("DigitalCertificate.importCRL", {
        DigitalCertificateType: DigitalCertificateType || "GM",
        CRL: CRL,
      });
    },
    exportCRL: (SN: unknown, DigitalCertificateType?: string) => {
      return this.send("DigitalCertificate.exportCRL", {
        DigitalCertificateType: DigitalCertificateType || "GM",
        SN: SN,
      });
    },
    deleteCRLs: (SN: unknown, DigitalCertificateType?: string) => {
      return this.send("DigitalCertificate.deleteCRLs", {
        DigitalCertificateType: DigitalCertificateType || "GM",
        SN: SN,
      });
    },
    createCert: (options: object, DigitalCertificateType?: string) => {
      return this.send("DigitalCertificate.createCert", {
        ...{
          DigitalCertificateType: DigitalCertificateType || "GM",
          Type: "Default",
        },
        ...options,
      });
    },
    setActiveServerCert: (
      ServerName: unknown,
      CertSN: unknown,
      DigitalCertificateType?: string
    ) => {
      return this.send("DigitalCertificate.setActiveServerCert", {
        DigitalCertificateType: DigitalCertificateType || "GM",
        ServerName: ServerName,
        CertSN: CertSN,
      });
    },
    getPublicKey: (Type?: number) => {
      return this.sendRPC(
        this.rpc("DigitalCertificate.getPublicKey", { Type: Type || 0 }),
        "/OutsideCmd"
      ).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/DockUser.ts
================================================
import { RPCBase } from "../rpcBase";

export function DockUser(this: RPCBase) {
  return {
    getUserInfoAll: () => {
      return this.send<{ users?: unknown[] }>("DockUser.getUserInfoAll").then(
        function (a) {
          return a.params.users || [];
        }
      );
    },
    addUser: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.send("DockUser.addUser", {
        salt: salt,
        cipher: cipher,
        content: content,
      });
    },
    deleteUser: (name: unknown) => {
      return this.send("DockUser.deleteUser", { name: name });
    },
    modifyPassword: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.send("DockUser.modifyPassword", {
        salt: salt,
        cipher: cipher,
        content: content,
      });
    },
    modifyUser: (name: unknown, user: unknown) => {
      return this.send("DockUser.modifyUser", { name: name, user: user });
    },
  };
}



================================================
FILE: lib/rpc/Encode.ts
================================================
import { RPCBase } from "../rpcBase";

export function Encode(this: RPCBase) {
  const instance = this.sendSetup("encode.factory.instance");
  return {
    instance,
    getConfigCaps: (channel: unknown, config: unknown, stream?: string) => {
      return this.send<{ caps: unknown }>("encode.getConfigCaps", {
        channel: channel,
        config: config,
        stream: stream || "All",
      }).then(function (a) {
        return a.params.caps;
      });
    },
    updateOverlayPicture: (Pictures: unknown) => {
      return this.send<{ Infos: unknown }>("encode.updateOverlayPicture", {
        Pictures: Pictures,
      }).then(function (a) {
        return a.params.Infos;
      });
    },
    getSmartCaps: (config: unknown, channel?: number) => {
      return this.send<{ caps: unknown }>("encode.getSmartCaps", {
        channel: channel || 0,
        config: config,
      }).then(function (a) {
        return a.params.caps;
      });
    },
    getCropCaps: (channel?: number) => {
      return this.send<{ caps: unknown }>("encode.getCropCaps", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params.caps;
      });
    },
    getNAACaps: (channel?: number) => {
      return this.send<{ caps: unknown }>("encode.getNAACaps", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params.caps;
      });
    },
    getCaps: (channel?: number) => {
      return this.send<{ caps: unknown }>("encode.getCaps", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params.caps;
      });
    },
  };
}



================================================
FILE: lib/rpc/EventManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function EventManager(this: RPCBase) {
  const instance = () => {
    return this.send("eventManager.factory.instance").then(function (a) {
      return a.result;
    });
  };
  return {
    instance,
    attach: (codes: string[], proc?: string) => {
      return this.send<undefined | { SID: string }>("eventManager.attach", {
        codes: codes,
        proc: proc,
      }).then(function (a) {
        return a.params && a.params.SID;
      });
    },
    detach: (SID: string, codes: string[], proc?: string) => {
      return this.send("eventManager.detach", {
        SID: SID,
        codes: codes,
        proc: proc,
      });
    },
    destroy: (object: string) => {
      return this.send("eventManager.destroy", null, { object: object });
    },
    confirmEvent: (code: string, index: number, name: string) => {
      return this.send("eventManager.confirmEvent", {
        code: code,
        index: index,
        name: name,
      }).then(function (a) {
        return a.result;
      });
    },
    getCaps: () => {
      return instance().then(() => {
        // (a) => {
        return this.send<{ caps: unknown }>("eventManager.getCaps", {
          // object: a.result // NOTE: This will always be undefined
        }).then(function (a) {
          return a.params.caps;
        });
      });
    },
    getEventLink: (code: string | string[]) => {
      return (
        "string" === typeof code && (code = [code]),
        this.send("eventManager.getEventLink", { code: code }).then(function (
          a
        ) {
          return a.params;
        })
      );
    },
    getEventIndexes: (code: string) => {
      return this.send<{ indexes?: unknown[] }>(
        "eventManager.getEventIndexes",
        { code: code }
      ).then(function (a) {
        return a.params.indexes || [];
      });
    },
    getEventData: (
      code: string,
      index: number,
      name: string,
      object: string
    ) => {
      return this.send(
        "eventManager.getEventData",
        { code: code, index: index, name: name },
        { object: object }
      ).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/ExternalSensorManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function ExternalSensorManager(this: RPCBase) {
  return {
    getCaps: () => {
      return this.send<{ caps: unknown }>("ExternalSensorManager.getCaps").then(
        function (a) {
          return a.params.caps;
        }
      );
    },
    startFind: (condition?: unknown) => {
      return this.send("ExternalSensorManager.startFind", {
        condition: condition,
      }).then(function (a) {
        return a.params;
      });
    },
    doFind: (token: unknown, begin: unknown, count: unknown) => {
      return this.send("ExternalSensorManager.doFind", {
        token: token,
        begin: begin,
        count: count,
      }).then(function (a) {
        return a.params;
      });
    },
    stopFind: (token: unknown) => {
      return this.send("ExternalSensorManager.stopFind", { token: token }).then(
        function (a) {
          return a.params;
        }
      );
    },
    discoverLabel: (type?: string) => {
      return this.send("ExternalSensorManager.discoverLabel", {
        type: type || "Sensor",
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/FaceBoard.ts
================================================
import { RPCBase } from "../rpcBase";

export function FaceBoard(this: RPCBase) {
  const instance = this.sendSetup("faceBoard.factory.instance");
  return {
    instance,
    getFanSpeedEx: (type: unknown) => {
      return instance().then((a) => {
        return this.send<{ info: unknown }>(
          "faceBoard.getFanSpeedEx",
          { type: type },
          { object: a.result }
        ).then(function (a) {
          return a.params.info;
        });
      });
    },
    getTemperatureEx: (type: unknown) => {
      return instance().then((a) => {
        return this.send<{ info: unknown }>(
          "faceBoard.getTemperatureEx",
          { type: type },
          { object: a.result }
        ).then(function (a) {
          return a.params.info;
        });
      });
    },
    getTemperature: () => {
      return instance().then((a) => {
        return this.send("faceBoard.getTemperature", void 0, {
          object: a.result,
        }).then(function (a) {
          return a.params;
        });
      });
    },
    getCaps: () => {
      return instance().then((a) => {
        return this.send<{ caps: unknown }>("faceBoard.getCaps", void 0, {
          object: a.result,
        }).then(function (a) {
          return a.params.caps;
        });
      });
    },
    getPowerState: () => {
      return instance().then((a) => {
        return this.send<{ state: unknown }>(
          "faceBoard.getPowerState",
          void 0,
          { object: a.result }
        ).then(function (a) {
          return a.params.state;
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/FaceFlowStat.ts
================================================
import { RPCBase } from "../rpcBase";

export function FaceFlowStat(this: RPCBase) {
  return {
    getCaps: () => {
      return this.send<{
        Caps: {
          Support: number;
        };
      }>("FaceFlowStat.getCaps").then(function (a) {
        return a.params.Caps;
      });
    },
    clearOSD: (channel?: number) => {
      return this.send("FaceFlowStat.clearOSD", { channel: channel || 0 });
    },
  };
}



================================================
FILE: lib/rpc/FaceRecognitionServer.ts
================================================
import { RPCBase } from "../rpcBase";

export function FaceRecognitionServer(this: RPCBase) {
  const instance = this.sendSetup("faceRecognitionServer.factory.instance");
  return {
    instance,
    createGroup: (
      GroupName?: string,
      GroupType?: string,
      GroupDetail?: string
    ) => {
      return instance().then((d) => {
        return this.send(
          "faceRecognitionServer.createGroup",
          {
            group: {
              GroupID: "",
              GroupName: GroupName || "",
              GroupType: GroupType || "BlackListDB",
              GroupDetail: GroupDetail || "",
            },
          },
          { object: d.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
    deleteGroup: (groupID: unknown) => {
      return instance().then((b) => {
        return this.send(
          "faceRecognitionServer.deleteGroup",
          { groupID: groupID },
          { object: b.result }
        );
      });
    },
    findGroup: (groupID?: string) => {
      return instance().then((b) => {
        return this.send<{ GroupList: unknown }>(
          "faceRecognitionServer.findGroup",
          { groupID: groupID || "" },
          { object: b.result }
        ).then(function (a) {
          return a.params.GroupList;
        });
      });
    },
    setGroup: (groupID: unknown, channel?: number) => {
      return instance().then((c) => {
        return this.send(
          "faceRecognitionServer.setGroup",
          { groupID: groupID, channel: channel || 0 },
          { object: c.result }
        );
      });
    },
    modifyGroup: (group: unknown) => {
      return instance().then((b) => {
        return this.send(
          "faceRecognitionServer.modifyGroup",
          { group: group },
          { object: b.result }
        );
      });
    },
    startFind: (person: unknown, condition: unknown, channel?: number) => {
      return instance().then((d) => {
        return this.send(
          "faceRecognitionServer.startFind",
          { person: person, condition: condition, channel: channel || 0 },
          { object: d.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
    doFind: (
      token: unknown,
      count: unknown,
      beginNumber?: number,
      NeedData?: number
    ) => {
      return instance().then((e) => {
        return this.send<{ results: unknown }>(
          "faceRecognitionServer.doFind",
          {
            condition: {
              token: token,
              count: count,
              NeedData: NeedData || 1,
              beginNumber: beginNumber || 0,
            },
          },
          { object: e.result }
        ).then(function (a) {
          return a.params.results;
        });
      });
    },
    stopFind: (token: unknown) => {
      return instance().then((b) => {
        return this.send(
          "faceRecognitionServer.stopFind",
          { token: token },
          { object: b.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
    deletePerson: (person: unknown) => {
      return instance().then((b) => {
        return this.send(
          "faceRecognitionServer.delete",
          { person: person },
          { object: b.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
    reAbstract: (person: unknown) => {
      return this.send("faceRecognitionServer.reAbstract", {
        person: person,
      }).then(function (a) {
        return a.params;
      });
    },
    groupReAbstract: (GroupID: unknown, Token: unknown) => {
      return this.send("faceRecognitionServer.groupReAbstract", {
        GroupID: GroupID,
        Token: Token,
      }).then(function (a) {
        return a.params;
      });
    },
    stopGroupReAbstract: (token: unknown) => {
      return this.send("faceRecognitionServer.stopGroupReAbstract", {
        token: token,
      });
    },
    stopReAbstract: () => {
      return this.send("faceRecognitionServer.stopReAbstract");
    },
    getGroupSpaceInfo: () => {
      return this.send("faceRecognitionServer.getGroupSpaceInfo").then(
        function (a) {
          return a.params;
        }
      );
    },
    getAppendToken: () => {
      return this.send("faceRecognitionServer.getAppendToken").then(function (
        a
      ) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/FileManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function FileManager(this: RPCBase) {
  return {
    list: (path: string) => {
      return this.send<{ elementInfo: unknown }>("FileManager.list", {
        path: path,
      })
        .then(function (a) {
          return a.params.elementInfo;
        })
        .catch(() => {
          return [];
        });
    },
    rename: (oldName: string, newName: string) => {
      return this.send("FileManager.rename", {
        oldName: oldName,
        newName: newName,
      });
    },
    removeFiles: (fileName: string) => {
      return this.send("FileManager.removeFiles", { fileName: fileName });
    },
    getFileNames: (directory: string) => {
      return this.send<{ fileInfo: unknown }>("FileManager.getFileNames", {
        directory: directory,
      }).then(function (a) {
        return a.params.fileInfo;
      });
    },
    downloadPiece: (fileName: string, offset: number, needLength: boolean) => {
      return this.send("FileManager.downloadPiece", {
        fileName: fileName,
        offset: offset,
        needLength: needLength,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/FlirDebug.ts
================================================
import { RPCBase } from "../rpcBase";

export function FlirDebug(this: RPCBase) {
  return {
    getSensorSetting: (cmd: unknown, maxoutLenth: unknown, inData: unknown) => {
      return this.send("FlirDebug.getSensorSetting", {
        cmd: cmd,
        maxOutLenth: maxoutLenth,
        inData: inData,
      }).then(function (a) {
        return a;
      });
    },
    setSensorSetting: (cmd: unknown, data: unknown) => {
      return this.send("FlirDebug.setSensorSetting", {
        cmd: cmd,
        data: data,
      }).then(function (a) {
        return a;
      });
    },
    getFFCStateInfo: () => {
      return this.send("FlirDebug.getFFCStateInfo", { params: null }).then(
        function (a) {
          return a;
        }
      );
    },
    getLastError: (maxoutLenth: unknown) => {
      return this.send("FlirDebug.getLastError", {
        maxOutLenth: maxoutLenth,
      }).then(function (a) {
        return a;
      });
    },
  };
}



================================================
FILE: lib/rpc/FontManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function FontManager(this: RPCBase) {
  return {
    getFontSolutionSet: () => {
      return this.send("fontManager.getFontSolutionSet").then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/FtpTest.ts
================================================
import { RPCBase } from "../rpcBase";

export function FtpTest(this: RPCBase) {
  return {
    checkAuthority: (name?: string) => {
      return this.send("FtpTest.checkAuthority", { name: name || "FTP1" });
    },
    getCaps: () => {
      return this.send<{
        caps: {
          Support: boolean;
        };
      }>("FtpTest.getCaps").then(function (a) {
        return a.params.caps;
      });
    },
  };
}



================================================
FILE: lib/rpc/GB35114Encrypt.ts
================================================
import { RPCBase } from "../rpcBase";

export function GB35114Encrypt(this: RPCBase) {
  return {
    getCurrentVKEKInfo: (Channel?: unknown) => {
      return this.send("GB35114Encrypt.getCurrentVKEKInfo", {
        Channel: Channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    getPastVKEKInfo: (StartTime: unknown, StopTime: unknown) => {
      return this.send("GB35114Encrypt.getPastVKEKInfo", {
        StartTime: StartTime,
        StopTime: StopTime,
      }).then(function (a) {
        return a.params;
      });
    },
    attachVKEKUpdate: () => {
      return this.send<{ SID: unknown }>(
        "GB35114Encrypt.attachVKEKUpdate"
      ).then(function (a) {
        return a.params.SID;
      });
    },
    detachVKEKUpdate: (SID: unknown) => {
      return this.send("GB35114Encrypt.detachVKEKUpdate", { SID: SID }).then(
        function (a) {
          return a;
        }
      );
    },
  };
}



================================================
FILE: lib/rpc/GpsControl.ts
================================================
import { RPCBase } from "../rpcBase";

export function GpsControl(this: RPCBase) {
  return {
    getCaps: (name?: string) => {
      return this.send("GpsControl.getCaps", { name: name || "All" }).then(
        function (a) {
          return a.params;
        }
      );
    },
    getGpsStatus: () => {
      return this.send("GpsControl.getGpsStatus").then(function (a) {
        return a.params;
      });
    },
    setWorkMode: (MODE: unknown) => {
      return this.send("GpsControl.setWorkMode", { info: { MODE: MODE } }).then(
        function (a) {
          return a.params;
        }
      );
    },
  };
}



================================================
FILE: lib/rpc/Gyro.ts
================================================
import { RPCBase } from "../rpcBase";

export function Gyro(this: RPCBase) {
  return {
    getData: () => {
      return this.send<{ detail: unknown }>("Gyro.getData").then(function (a) {
        return a.params.detail;
      });
    },
  };
}



================================================
FILE: lib/rpc/index.ts
================================================
import { RPCBase } from "../rpcBase";
import { Alarm } from "./Alarm";
import { AroudWifi } from "./AroudWifi";
import { AsyncDeviceManager } from "./AsyncDeviceManager";
import { AudioRecordManager } from "./AudioRecordManager";
import { AuthPTZ } from "./AuthPTZ";
import { Backup } from "./Backup";
import { BlueToothDeviceManager } from "./BlueToothDeviceManager";
import { CertManager } from "./CertManager";
import { CloudUpgrader } from "./CloudUpgrader";
import { CoaxialControlIO } from "./CoaxialControlIO";
import { CommPort } from "./CommPort";
import { ConfigManager } from "./ConfigManager";
import { DdnsClient } from "./DdnsClient";
import { DevAudioDetect } from "./DevAudioDetect";
import { DevAudioEncode } from "./DevAudioEncode";
import { DevAudioInput } from "./DevAudioInput";
import { DevAudioOutput } from "./DevAudioOutput";
import { DevFlashLampManager } from "./DevFlashLampManager";
import { DevInit } from "./DevInit";
import { DevIntelliTracker } from "./DevIntelliTracker";
import { DevStorage } from "./DevStorage";
import { DevVariableCapsManager } from "./DevVariableCapsManager";
import { DevVideoAnalyse } from "./DevVideoAnalyse";
import { DevVideoDetect } from "./DevVideoDetect";
import { DevVideoEncode } from "./DevVideoEncode";
import { DevVideoInput } from "./DevVideoInput";
import { DevVideoOutput } from "./DevVideoOutput";
import { DigitalCertificate } from "./DigitalCertificate";
import { DockUser } from "./DockUser";
import { Encode } from "./Encode";
import { EventManager } from "./EventManager";
import { ExternalSensorManager } from "./ExternalSensorManager";
import { FaceBoard } from "./FaceBoard";
import { FaceFlowStat } from "./FaceFlowStat";
import { FaceRecognitionServer } from "./FaceRecognitionServer";
import { FileManager } from "./FileManager";
import { FlirDebug } from "./FlirDebug";
import { FontManager } from "./FontManager";
import { FtpTest } from "./FtpTest";
import { GB35114Encrypt } from "./GB35114Encrypt";
import { GpsControl } from "./GpsControl";
import { Gyro } from "./Gyro";
import { InstallManager } from "./InstallManager";
import { IntelliSnapshot } from "./IntelliSnapshot";
import { IntervideoClient } from "./IntervideoClient";
import { IntervideoManager } from "./IntervideoManager";
import { LensFunc } from "./LensFunc";
import { License } from "./License";
import { Log } from "./Log";
import { LogOnlineBackup } from "./LogOnlineBackup";
import { MagicBox } from "./MagicBox";
import { masterSlaveGroup } from "./masterSlaveGroup";
import { MediaFileFind } from "./MediaFileFind";
import { MultiVideo } from "./MultiVideo";
import { Nat } from "./Nat";
import { NetApp } from "./NetApp";
import { OSDManager } from "./OSDManager";
import { PasswdFind } from "./PasswdFind";
import { PeripheralChip } from "./PeripheralChip";
import { PortraitFlowStat } from "./PortraitFlowStat";
import { PrivacyMasking } from "./PrivacyMasking";
import { PTZ } from "./PTZ";
import { PTZBase } from "./PTZBase";
import { PtzPeripheral } from "./PtzPeripheral";
import { PtzViewRange } from "./PtzViewRange";
import { RainBrush } from "./RainBrush";
import { RecordFinder } from "./RecordFinder";
import { RecordManager } from "./RecordManager";
import { RecordUpdater } from "./RecordUpdater";
import { RemoteUpgrader } from "./RemoteUpgrader";
import { RfidManager } from "./RfidManager";
import { ScenicSpot } from "./ScenicSpot";
import { SDEncrypt } from "./SDEncrypt";
import { Security } from "./Security";
import { SnapManager } from "./SnapManager";
import { Speak } from "./Speak";
import { Storage } from "./Storage";
import { StreamUrlService } from "./StreamUrlService";
import { System } from "./System";
import { TemperCorrection } from "./TemperCorrection";
import { ThermographyLog } from "./ThermographyLog";
import { ThermoPrivateParam } from "./ThermoPrivateParam";
import { trafficFlowStat } from "./trafficFlowStat";
import { TrafficSnap } from "./TrafficSnap";
import { TrafficStatistic } from "./TrafficStatistic";
import { Upgrader } from "./Upgrader";
import { UpgraderInstall } from "./UpgraderInstall";
import { UPnPPortmap } from "./UPnPPortmap";
import { UserManager } from "./UserManager";
import { UWB } from "./UWB";
import { vehiclesDistribution } from "./vehiclesDistribution";
import { videoCalibrateServer } from "./videoCalibrateServer";
import { VideoInAnalyse } from "./VideoInAnalyse";
import { VideoProcessManager } from "./VideoProcessManager";
import { VideoStatServer } from "./VideoStatServer";
import { WebInit } from "./WebInit";
import { WideViewControl } from "./WideViewControl";
import { wire802File } from "./wire802File";
import { WlanManager } from "./WlanManager";
import { WorkDirectory } from "./WorkDirectory";
import { WorkGroup } from "./WorkGroup";

/**
 * Default RPC class that has all the modules implemented.
 */
export class RPC extends RPCBase {
  Alarm = Alarm.bind(this)();
  AroudWifi = AroudWifi.bind(this)();
  AsyncDeviceManager = AsyncDeviceManager.bind(this)();
  AudioRecordManager = AudioRecordManager.bind(this)();
  AuthPTZ = AuthPTZ.bind(this)();
  Backup = Backup.bind(this)();
  BlueToothDeviceManager = BlueToothDeviceManager.bind(this)();
  CertManager = CertManager.bind(this)();
  CloudUpgrader = CloudUpgrader.bind(this)();
  CoaxialControlIO = CoaxialControlIO.bind(this)();
  CommPort = CommPort.bind(this)();
  ConfigManager = ConfigManager.bind(this)();
  DdnsClient = DdnsClient.bind(this)();
  DevAudioDetect = DevAudioDetect.bind(this)();
  DevAudioEncode = DevAudioEncode.bind(this)();
  DevAudioInput = DevAudioInput.bind(this)();
  DevAudioOutput = DevAudioOutput.bind(this)();
  DevFlashLampManager = DevFlashLampManager.bind(this)();
  DevInit = DevInit.bind(this)();
  DevIntelliTracker = DevIntelliTracker.bind(this)();
  DevStorage = DevStorage.bind(this)();
  DevVariableCapsManager = DevVariableCapsManager.bind(this)();
  DevVideoAnalyse = DevVideoAnalyse.bind(this)();
  DevVideoDetect = DevVideoDetect.bind(this)();
  DevVideoEncode = DevVideoEncode.bind(this)();
  DevVideoInput = DevVideoInput.bind(this)();
  DevVideoOutput = DevVideoOutput.bind(this)();
  DigitalCertificate = DigitalCertificate.bind(this)();
  DockUser = DockUser.bind(this)();
  Encode = Encode.bind(this)();
  EventManager = EventManager.bind(this)();
  ExternalSensorManager = ExternalSensorManager.bind(this)();
  FaceBoard = FaceBoard.bind(this)();
  FaceFlowStat = FaceFlowStat.bind(this)();
  FaceRecognitionServer = FaceRecognitionServer.bind(this)();
  FileManager = FileManager.bind(this)();
  FlirDebug = FlirDebug.bind(this)();
  FontManager = FontManager.bind(this)();
  FtpTest = FtpTest.bind(this)();
  GB35114Encrypt = GB35114Encrypt.bind(this)();
  GpsControl = GpsControl.bind(this)();
  Gyro = Gyro.bind(this)();
  InstallManager = InstallManager.bind(this)();
  IntelliSnapshot = IntelliSnapshot.bind(this)();
  IntervideoClient = IntervideoClient.bind(this)();
  IntervideoManager = IntervideoManager.bind(this)();
  LensFunc = LensFunc.bind(this)();
  License = License.bind(this)();
  LogOnlineBackup = LogOnlineBackup.bind(this)();
  Log = Log.bind(this)();
  MagicBox = { ...MagicBoxExt.bind(this)(), ...MagicBox.bind(this)() };
  masterSlaveGroup = masterSlaveGroup.bind(this)();
  MediaFileFind = MediaFileFind.bind(this)();
  MultiVideo = MultiVideo.bind(this)();
  Nat = Nat.bind(this)();
  NetApp = NetApp.bind(this)();
  OSDManager = OSDManager.bind(this)();
  PasswdFind = PasswdFind.bind(this)();
  PeripheralChip = PeripheralChip.bind(this)();
  PortraitFlowStat = PortraitFlowStat.bind(this)();
  PrivacyMasking = PrivacyMasking.bind(this)();
  PTZBase = PTZBase.bind(this)();
  PtzPeripheral = PtzPeripheral.bind(this)();
  PTZ = PTZ.bind(this)();
  PtzViewRange = PtzViewRange.bind(this)();
  RainBrush = RainBrush.bind(this)();
  RecordFinder = RecordFinder.bind(this)();
  RecordManager = RecordManager.bind(this)();
  RecordUpdater = RecordUpdater.bind(this)();
  RemoteUpgrader = RemoteUpgrader.bind(this)();
  RfidManager = RfidManager.bind(this)();
  ScenicSpot = ScenicSpot.bind(this)();
  SDEncrypt = SDEncrypt.bind(this)();
  Security = Security.bind(this)();
  SnapManager = SnapManager.bind(this)();
  Speak = Speak.bind(this)();
  Storage = { ...StorageExt.bind(this)(), ...Storage.bind(this)() };
  StreamUrlService = StreamUrlService.bind(this)();
  System = System.bind(this)();
  TemperCorrection = TemperCorrection.bind(this)();
  ThermographyLog = ThermographyLog.bind(this)();
  ThermoPrivateParam = ThermoPrivateParam.bind(this)();
  trafficFlowStat = trafficFlowStat.bind(this)();
  TrafficSnap = TrafficSnap.bind(this)();
  TrafficStatistic = TrafficStatistic.bind(this)();
  UpgraderInstall = UpgraderInstall.bind(this)();
  Upgrader = Upgrader.bind(this)();
  UPnPPortmap = UPnPPortmap.bind(this)();
  UserManager = UserManager.bind(this)();
  UWB = UWB.bind(this)();
  vehiclesDistribution = vehiclesDistribution.bind(this)();
  videoCalibrateServer = videoCalibrateServer.bind(this)();
  VideoInAnalyse = VideoInAnalyse.bind(this)();
  VideoProcessManager = VideoProcessManager.bind(this)();
  VideoStatServer = VideoStatServer.bind(this)();
  WebInit = WebInit.bind(this)();
  WideViewControl = WideViewControl.bind(this)();
  wire802File = wire802File.bind(this)();
  WlanManager = WlanManager.bind(this)();
  WorkDirectory = WorkDirectory.bind(this)();
  WorkGroup = WorkGroup.bind(this)();
}

export function StorageExt(this: RPCBase) {
  type Response = Array<{
    Name: string;
    State: string;
    Detail: Array<{
      Path: string;
      Type: string;
      TotalBytes: number;
      UsedBytes: number;
      IsError: boolean;
    }>;
    CantHotPlug?: false;
    HealthDataFlag?: 0;
    LifePercent?: 0;
    LockState?: 0;
    Pointer?: 1;
    SDEncryptFlag?: 0;
  }>;
  return {
    getDeviceAllInfo: () => {
      return this.send("storage.factory.instance").then((a) => {
        return this.send<{ info: Response }>(
          "storage.getDeviceAllInfo",
          void 0,
          { object: a.result }
        ).then(function (a) {
          return a.params.info || a.params;
        });
      });
    },
  };
}

export function MagicBoxExt(this: RPCBase) {
  return {
    getOSInfo: () => {
      return this.send<{ info: { Type: unknown } }>("magicBox.getOSInfo").then(
        function (a) {
          return a.params.info.Type;
        }
      );
    },
    getUpTime: () => {
      return this.send<{
        info: {
          // Uptime
          Last: number;
          // IDK
          Total: number;
        };
      }>("magicBox.getUpTime").then(function (a) {
        return a.params.info;
      });
    },
  };
}



================================================
FILE: lib/rpc/InstallManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function InstallManager(this: RPCBase) {
  return {
    start: (appname: unknown, appid: unknown) => {
      return this.send("installManager.start", {
        appname: appname,
        appid: appid,
      });
    },
    stop: (appname: unknown, appid: unknown) => {
      return this.send("installManager.stop", {
        appname: appname,
        appid: appid,
      });
    },
    remove: (appname: unknown, appid: unknown) => {
      return this.send("installManager.remove", {
        appname: appname,
        appid: appid,
      });
    },
    getInstallProcInfo: () => {
      return this.send("installManager.getInstallProcInfo", null);
    },
    getState: () => {
      return this.send("installManager.getState", null);
    },
    getDhopBasicInfo: () => {
      return this.send("installManager.getDhopBasicInfo", null);
    },
    getAppResources: (AppName: unknown) => {
      return this.send("installManager.getAppResources", { AppName: AppName });
    },
  };
}



================================================
FILE: lib/rpc/IntelliSnapshot.ts
================================================
import { RPCBase } from "../rpcBase";

export function IntelliSnapshot(this: RPCBase) {
  return {
    manualSnapByEvent: (
      EventCode: unknown,
      Times: unknown,
      Channel?: number
    ) => {
      return this.send("IntelliSnapshot.manualSnapByEvent", {
        Channel: Channel || 0,
        Info: { EventCode: EventCode, Times: Times },
      }).then(function (a) {
        return a;
      });
    },
  };
}



================================================
FILE: lib/rpc/IntervideoClient.ts
================================================
import { RPCBase } from "../rpcBase";

export function IntervideoClient(this: RPCBase) {
  return {
    getVersion: (name?: unknown) => {
      return this.send<{ info?: unknown[] }>("IntervideoClient.getVersion", {
        name: name,
      }).then(function (a) {
        return a.params.info || [];
      });
    },
  };
}



================================================
FILE: lib/rpc/IntervideoManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function IntervideoManager(this: RPCBase) {
  return {
    getVersion: (Name: unknown) => {
      return this.send<{ info: object }>("IntervideoManager.getVersion", {
        Name: Name,
      }).then(function (a) {
        return a.params.info || {};
      });
    },
    getNetStatus: () => {
      return this.send<{ info: unknown }>(
        "IntervideoManager.getNetStatus"
      ).then(function (a) {
        return a.params.info;
      });
    },
  };
}



================================================
FILE: lib/rpc/LensFunc.ts
================================================
import { RPCBase } from "../rpcBase";

export function LensFunc(this: RPCBase) {
  return {
    getBackFocusStatus: (channel?: number) => {
      return this.send<{ status: unknown }>("LensFunc.getBackFocusStatus", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params.status;
      });
    },
    autoBackFocus: (channel?: number) => {
      return this.send("LensFunc.autoBackFocus", { channel: channel || 0 });
    },
    getDepthFieldStatus: (Channel?: number) => {
      return this.send<{ status: unknown }>("LensFunc.getDepthFieldStatus", {
        Channel: Channel || 0,
      }).then(function (a) {
        return a.params.status;
      });
    },
    adjustDepthFieldContinuously: (
      DepthFieldSpeed: unknown,
      channel?: number
    ) => {
      return this.send("LensFunc.adjustDepthFieldContinuously", {
        Channel: channel || 0,
        DepthFieldSpeed: DepthFieldSpeed,
      });
    },
    backFocusContinuously: (speed: unknown, channel?: number) => {
      return this.send("LensFunc.backFocusContinuously", {
        channel: channel || 0,
        speed: speed,
      });
    },
    backFocusAbsolutely: (focus: unknown, channel?: number) => {
      return this.send("LensFunc.backFocusAbsolutely", {
        channel: channel || 0,
        focus: focus,
      });
    },
    resetBackFocus: (channel?: number) => {
      return this.send("LensFunc.resetBackFocus", { channel: channel || 0 });
    },
    getDebugCaps: (channel?: number) => {
      return this.send("LensFunc.getDebugCaps", { channel: channel || 0 }).then(
        function (a) {
          return a.params;
        }
      );
    },
    switchDefogFilter: (switchDirection: unknown, channel?: number) => {
      return this.send("LensFunc.switchDefogFilter", {
        channel: channel || 0,
        switchDirection: switchDirection,
      });
    },
    twoPowerLens: (enable: unknown, channel?: number) => {
      return this.send("LensFunc.twoPowerLens", {
        channel: channel || 0,
        enable: enable,
      });
    },
    getLensPMSamplingValue: (channel?: number) => {
      return this.send("LensFunc.getLensPMSamplingValue", {
        channel: channel || 0,
      });
    },
    getLensInfo: (Channel?: number) => {
      return this.send<{ Info: unknown }>("LensFunc.getLensInfo", {
        Channel: Channel || 0,
      }).then(function (a) {
        return a.params.Info;
      });
    },
    adjustFocusRel: (CmdInfo: unknown, Channel?: number) => {
      return this.send("LensFunc.adjustFocusRel", {
        Channel: Channel || 0,
        CmdInfo: CmdInfo,
      });
    },
    adjustDepthField: (DepthField: unknown, Channel?: number) => {
      return this.send("LensFunc.adjustDepthField", {
        Channel: Channel || 0,
        DepthField: DepthField,
      });
    },
    autoAdjustDepthField: (Channel?: number) => {
      return this.send("LensFunc.autoAdjustDepthField", {
        Channel: Channel || 0,
      });
    },
    adjustAngleContinuously: (
      Channel?: number,
      Direction?: unknown,
      Velocity?: unknown
    ) => {
      return this.send("LensFunc.adjustAngleContinuously", {
        Channel: Channel || 0,
        Direction: Direction,
        Velocity: Velocity,
      });
    },
    stopAdjustingAngle: (Channel?: number) => {
      return this.send("LensFunc.stopAdjustingAngle", {
        Channel: Channel || 0,
      });
    },
    getCaps: (Channel?: number) => {
      return this.send<{ Caps: unknown }>("LensFunc.getCaps", {
        Channel: Channel || 0,
      }).then(function (a) {
        return a.params.Caps;
      });
    },
    correctScene: (
      Channel?: number,
      Type?: unknown,
      Direction?: unknown,
      Step?: unknown,
      Mode?: unknown
    ) => {
      return this.send("LensFunc.correctScene", {
        Channel: Channel || 0,
        Type: Type,
        Direction: Direction,
        Step: Step,
        Mode: Mode || 0,
      });
    },
  };
}



================================================
FILE: lib/rpc/License.ts
================================================
import { RPCBase } from "../rpcBase";

export function License(this: RPCBase) {
  return {
    getLicenseInfo: () => {
      return this.send<
        Array<{
          Info: {
            AbroadInfo: string;
            AllType: boolean;
            BusinessLimit: Array<{
              LimitItems: Array<{
                Policy: number;
                Value: number;
              }>;
              Type: number;
            }>;
            ClusterLimit: Array<{
              Policy: number;
              Value: number;
            }>;
            DigitChannel: number;
            EffectiveDays: number;
            EffectiveTime: number;
            LicenseID: number;
            ProductType: string;
            Status: number;
            Username: string;
          };
        }>
      >("License.getLicenseInfo").then(function (a) {
        return a && a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/Log.ts
================================================
import { RPCBase } from "../rpcBase";

export function Log(this: RPCBase) {
  return {
    startFind: (condition: unknown) => {
      return this.send<{ token: unknown }>("log.startFind", {
        condition: condition,
      }).then(function (a) {
        return a.params.token;
      });
    },
    getCount: (token: unknown) => {
      return new Promise((resolve, reject) => {
        this.send<{ count: unknown }>("log.getCount", { token: token })
          .then(function (b) {
            "number" === typeof b.params.count
              ? resolve(b.params.count)
              : reject();
          })
          .catch(reject);
      });
    },
    append: (
      type: unknown,
      detail: unknown,
      device: unknown,
      user: unknown
    ) => {
      return this.send("log.append", {
        type: type,
        detail: detail,
        device: device,
        user: user,
      }).then(function (a) {
        return a.params;
      });
    },
    doSeekFind: (token: unknown, offset: unknown, count: unknown) => {
      return this.send("log.doSeekFind", {
        token: token,
        offset: offset,
        count: count,
      }).then(function (a) {
        return a.params;
      });
    },
    stopFind: (token: unknown) => {
      return this.send("log.stopFind", { token: token });
    },
    clear: () => {
      return this.send("log.clear");
    },
  };
}



================================================
FILE: lib/rpc/LogOnlineBackup.ts
================================================
import { RPCBase } from "../rpcBase";

export function LogOnlineBackup(this: RPCBase) {
  return {
    getCaps: () => {
      return this.send("LogOnlineBackup.getCaps").then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/MagicBox.ts
================================================
import { RPCBase } from "../rpcBase";

export type ProductDefinitions =
  | "HasPtz"
  | "IsPtzAlarm"
  | "VSP"
  | "MaxExtraStream"
  | "CameraSwitchComV"
  | "IsLocalStore"
  | "IEEE802_1X"
  | "VPN"
  | "SupportedWPS"
  | "CameraAttribute"
  | "PtzFunctionMenu"
  | "LightingControl"
  | "RainBrushControl"
  | "CifPFrameSize"
  | "AudioFileManager"
  | "LegalinfoCaps"
  | "AudioProperties"
  | "WirelessAlarm"
  | "GB28181"
  | "VolumeDetect"
  | "AnomalyDetect"
  | "MutationDetect"
  | "MajorVersion"
  | "MinorVersion"
  | "VendorAbbr"
  | "OEMVersion"
  | "Revision"
  | "TypeVersion"
  | "BuildDate"
  | "WebVersion"
  | "MaxPreRecordTime"
  | "PartSolution"
  | "PTZFunctionViaApp"
  | "IntelliTracker"
  | "VSPs"
  | "FontColour"
  | "FontBorder"
  | "SafetyAbnormalAbility"
  | "FontSize"
  | "QueryDatabase"
  | "PtzManualMotionDetect"
  | "VideoAnalyse"
  | "VideoStandards"
  | "Languages"
  | "SnapshotInterval"
  | "IsGpsInfoOsd"
  | "PtzOperationStatus"
  | "Focus"
  | "Iris"
  | "RotateResolutionLimit"
  | "EncodingResolutionLimit"
  | "SpecVer"
  | "LensControl"
  | "LensControlMix"
  | "smallPtz"
  | "FireWarning"
  | "TemperatureDifference"
  | "PresetFocusROI"
  | "IntelligentFocus"
  | "Industry"
  | "SteadyLightControl"
  | "CSCMatrixSwitch"
  | "TrackPositionLimit"
  | "AroudWifiSearch"
  | "VideoOutControlMode"
  | "CaptureSetResolution"
  | "SupportHardwarePtzDevice"
  | "AudioTalkMode"
  | "PtzDirectionCalibration"
  | "MeasureDistance"
  | "EncodePriority"
  | "PtzViewSector"
  | "SyncTime"
  | "SupportFlipTransducer"
  | "MagSensor"
  | "SIMLimit"
  | "OSDMobileState"
  | "LensZoomThermal"
  | "SupportAudioChangeVoice"
  | "EmailIntervalVisible"
  | "UWBConfig"
  | "DynamicROI"
  | "PtzRoadInfo"
  | "FaceDetection"
  | "SupportTempSensing"
  | "BFFunction"
  | "AutoFocus"
  | "StreamAuthority"
  | "SSHD"
  | "ConfigBackupFilelist"
  | "SupportedTrafficTrustList"
  | "BurningCheck"
  | "DecodeBuf"
  | "VideoInImageGird"
  | "HLSCaps"
  | "SupportCloudUpgrade"
  | "ManagerModifyPwd"
  | "SupportSetPtzTour"
  | "HighZoomPtzMoveAdaptor"
  | "LaserControl"
  | "RadioMetry"
  | "FaceAnalysis"
  | "ShutterAbnormal"
  | "IntelliFrameCaps"
  | "HotColdSpotTrace"
  | "IsProtectCover"
  | "SpecifyAreaEnhance"
  | "HasPtzMCU"
  | "IPCRecordBatchDownload"
  | "SupportShortTour"
  | "SuggestEncode"
  | "SupportMultiRTPDH"
  | "P2P"
  | "SupportShowMultiTS"
  | "PrivacyMasking"
  | "NetMode"
  | "SupportPtzFunction"
  | "AutoFocusButtonVisible"
  | "AutoFocusButtonThermal"
  | "ZoomThermal"
  | "FocusThermal"
  | "IsSimplifiedPtz"
  | "ShowPtzMoveStatus"
  | "SupportPlateDetectCfg"
  | "AudioProperty"
  | "ObjectTrack"
  | "VideoConfig"
  | "MultVideoSensor"
  | "PtzAutoMovement"
  | "IdleMotion"
  | "SupportPtzCfgImExport"
  | "PanoramaDrag"
  | "PicInPic"
  | "SFFCFunc"
  | "SupportTrafficPreSendPic"
  | "SupportMediaEncrypt"
  | "SupportCGICfg"
  | "SupportOnvifCfg"
  | "SupportGenetecCfg"
  | "SupportMobilePush"
  | "SupportFileBackupEncrypt"
  | "SystemService"
  | "SupportBitRateUnite"
  | "BlkBdySampFunc"
  | "GPS"
  | "Dhop"
  | "SupportPresetOsdTime"
  | "CameraUpdatePowerOff"
  | "SupportDHTSforRTSP"
  | "MulNetwokrDial"
  | "SupportPirMotionRegion"
  | "ThermDenoiseFunc"
  | "SupportPreceptionPlatformAccess"
  | "ObjectDetect"
  | "Gate"
  | "SupportOsdRestructure"
  | "SupportGB35114Level"
  | "SupportMutiGB"
  | "FlowStat"
  | "SupportSafetyAbnormalAlarm"
  | "IPTableFilter"
  | "AutoFovCalibrate"
  | "ThermographyFusion"
  | "Dhop"
  | "VoltageStatus"
  | "SupportPTZZoom"
  | "OsdContainer"
  | "PtzHeater"
  | "OsdPutTogether"
  | "SupportCertificateSet"
  | "SmartEncodeChangeNeedReboot"
  | "IntelliTypeMap"
  | "SupportShowGaysVersion"
  | "VideoInSceneLink"
  | "PositionSnap"
  | "SensorMaintain"
  | "AnimalFlowStat"
  | "ThermLog"
  | "SupportSerialNo"
  | "IsRicfDevice"
  | "SupportStoreEncrypt"
  | "SupportDownloadEncrypt"
  | "SupportLoginAuthCtrl"
  | "ManualSnapshot"
  | "IsRiskTipEnable"
  | "SupportAIView"
  | "AOLCaps"
  | "SupportDisableLinkage"
  | "NumberStatMult"
  | "BinocularCalibrate"
  | "SnapResolutionAdjustedMap"
  | "WideDynamic"
  | "SpliceFusionEnhancement"
  | "SpliceSetting"
  | "BiologyFunc"
  | "ConchDevice"
  | "AIViewSupportList"
  | "SupportAPView"
  | "TempBalanceThreshold"
  | "TecMultistage"
  | "ParkingSpace"
  | "ShowAlgorCalibrate"
  | "CardMachine"
  | "SupportPort5000"
  | "AIOTSupportList"
  | "PortraitDetection"
  | "TecReplaceCavity"
  | "CaliEnvTempCompense"
  | "SupportAlgorithmURLUpgrade"
  | "SmokeDetection";

export function MagicBox(this: RPCBase) {
  return {
    reboot: () => {
      return this.send("magicBox.reboot").then(function (a) {
        return a.result;
      });
    },
    needReboot: () => {
      return this.send<{ needReboot: boolean }>("magicBox.needReboot").then(
        function (a) {
          return a.params.needReboot;
        }
      );
    },
    getMainBoardCount: () => {
      return this.send<{ count: boolean }>("magicBox.getMainBoardCount").then(
        function (a) {
          return a.params.count;
        }
      );
    },
    getSerialNo: () => {
      return this.send<{ sn: string }>("magicBox.getSerialNo").then(function (
        a
      ) {
        return a.params.sn;
      });
    },
    getProductDefinition: (
      definitionOrArray: ProductDefinitions | ProductDefinitions[]
    ) => {
      return Array.isArray(definitionOrArray)
        ? this.send(
            "magicBox.getProductDefinition",
            definitionOrArray.map<{ name: string }>((a) => {
              return { name: a };
            })
          ).then(function (a) {
            return a.params;
          })
        : this.send<{ definition: string[] }>("magicBox.getProductDefinition", {
            name: definitionOrArray,
          }).then(function (a) {
            return a.params.definition;
          });
    },
    getDeviceType: () => {
      return this.send<{ type: string }>("magicBox.getDeviceType").then(
        function (a) {
          return a.params.type;
        }
      );
    },
    getMemoryInfo: () => {
      return this.send<{ free: number; total: number }>(
        "magicBox.getMemoryInfo"
      ).then(function (a) {
        return a.params;
      });
    },
    getCPUUsage: (index: number) => {
      return this.send<{ usage: number }>("magicBox.getCPUUsage", {
        index: index || 0,
      }).then(function (a) {
        return a.params.usage;
      });
    },
    getDeviceClass: () => {
      return this.send<{ type: string }>("magicBox.getDeviceClass").then(
        function (a) {
          return a.params.type;
        }
      );
    },
    getProcessInfo: () => {
      return this.send<{ info: string }>("magicBox.getProcessInfo").then(
        function (a) {
          return a.params.info;
        }
      );
    },
    getSubModules: () => {
      return this.send<{ subModules: unknown }>("magicBox.getSubModules").then(
        function (a) {
          return a.params.subModules;
        }
      );
    },
    get2DCode: (type: unknown) => {
      return this.send<{ code: unknown }>("magicBox.get2DCode", {
        type: type,
      }).then(
        function (b) {
          return new Promise(function (resolve, reject) {
            const d = b.params.code;
            d ? resolve(d) : reject("");
          });
        },
        function () {
          return "";
        }
      );
    },
    getSystemInfoNew: () => {
      return this.send<{ info: unknown }>("magicBox.getSystemInfoNew").then(
        function (a) {
          return a.params.info;
        }
      );
    },
    getHardwareVersion: () => {
      return this.send<{ version: string }>("magicBox.getHardwareVersion").then(
        function (a) {
          return a.params.version;
        }
      );
    },
    getVendor: () => {
      return this.send<{ Vendor: string }>("magicBox.getVendor").then(function (
        a
      ) {
        return a.params.Vendor;
      });
    },
    shutDown: () => {
      return this.send("magicBox.shutdown");
    },
    getHardwareType: () => {
      return this.send("magicBox.getHardwareType").then(function (a) {
        return a.params;
      });
    },
    getSoftwareVersion: () => {
      return this.send<{
        version: {
          Build?: string;
          BuildDate: string;
          SecurityBaseLineVersion: string;
          Version: string;
          WebVersion: string;
        };
      }>("magicBox.getSoftwareVersion").then(function (a) {
        return a.params;
      });
    },
    getMarketArea: () => {
      return this.send<{ AbroadInfo: string }>("magicBox.getMarketArea").then(
        function (a) {
          return a.params.AbroadInfo;
        }
      );
    },
    getAreaCode: () => {
      return this.send<{ AreaCode: number[] } | null>(
        "magicBox.getAreaCode"
      ).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/masterSlaveGroup.ts
================================================
import { RPCBase } from "../rpcBase";

export function masterSlaveGroup(this: RPCBase) {
  return {
    open: (group: unknown, slave: unknown) => {
      return this.send("masterSlaveGroup.open", {
        group: group,
        slave: slave,
      }).then(
        function (a) {
          return a.params;
        },
        function () {
          return !1;
        }
      );
    },
    locate: (token: unknown, point: unknown, masterInfo?: unknown) => {
      return this.send("masterSlaveGroup.locate", {
        token: token,
        point: point,
        masterInfo: masterInfo || null,
      }).then(function (a) {
        return a.params;
      });
    },
    track: (token: unknown, objectID: unknown) => {
      return this.send("masterSlaveGroup.track", {
        token: token,
        objectID: objectID,
        class: "Normal",
      }).then(function (a) {
        return a.params;
      });
    },
    rectLocate: (token: unknown, rect: unknown, Direction: unknown) => {
      return this.send("masterSlaveGroup.rectLocate", {
        token: token,
        rect: rect,
        Direction: Direction,
      }).then(function (a) {
        return a.params;
      });
    },
    attach: (group: unknown) => {
      return this.send("masterSlaveGroup.attach", { group: group }).then(
        function (a) {
          return a.params;
        }
      );
    },
    detach: (SID: unknown) => {
      return this.send("masterSlaveGroup.detach", { SID: SID }).then(function (
        a
      ) {
        return a.params;
      });
    },
    getCaps: () => {
      return this.send("masterSlaveGroup.getCaps").then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/MediaFileFind.ts
================================================
import { RPCBase } from "../rpcBase";

export type FindFileCondition = {
  Channel: number;
  Dirs: string[];
  Types: ["dav" | "jpg"] | ["dav", "jpg"] | ["jpg", "dav"];
  Order: "Ascent" | string;
  Redundant: "Exclusion" | string;
  Events: null | string[];
  StartTime: string;
  EndTime: string;
  Flags: string[];
};

export function MediaFileFind(this: RPCBase) {
  return {
    create: (subClassID?: number) => {
      return this.send<unknown, number>(
        "mediaFileFind.factory.create",
        void 0,
        {
          subClassID: subClassID,
        }
      ).then(function (a) {
        return a.result;
      });
    },
    findFile: (object: number, condition: FindFileCondition) => {
      return this.send(
        "mediaFileFind.findFile",
        { condition: condition },
        { object: object }
      );
    },
    findNextFile: (object: number, count: number) => {
      return this.send<{
        found: number;
        infos: Array<{
          Channel: number;
          StartTime: string;
          EndTime: string;
          Length: number;
          Type: "dav" | "jpg";
          FilePath: string;
          Duration: number;
          Disk: number;
          VideoStream: string;
          Flags: Array<string>;
          Events: Array<string>;
          Cluster?: number;
          Partition?: number;
          PicIndex?: number;
          Repeat?: number;
          WorkDir?: string;
          WorkDirSN?: number;
        }> | null;
      }>(
        "mediaFileFind.findNextFile",
        { count: count },
        { object: object }
      ).then(function (a) {
        return a.params;
      });
    },
    getCount: (object: number) => {
      return this.send<{ count: number }>("mediaFileFind.getCount", void 0, {
        object: object,
      }).then(function (a) {
        return a.params.count;
      });
    },
    setQueryResultOptions: (object: number, offset: number) => {
      return this.send(
        "mediaFileFind.setQueryResultOptions",
        { options: { offset: offset } },
        { object: object }
      ).then(function (a) {
        return a.result;
      });
    },
    close: (object: number) => {
      return this.send("mediaFileFind.close", void 0, { object: object });
    },
    destroy: (object: number) => {
      return this.send("mediaFileFind.destroy", void 0, { object: object });
    },
  };
}



================================================
FILE: lib/rpc/MultiVideo.ts
================================================
import { RPCBase } from "../rpcBase";

export function MultiVideo(this: RPCBase) {
  return {
    getSpliceCaps: (channel?: number) => {
      return this.send<{ Caps: unknown }>("MultiVideo.getSpliceCaps", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params.Caps;
      });
    },
  };
}



================================================
FILE: lib/rpc/Nat.ts
================================================
import { RPCBase } from "../rpcBase";

export function Nat(this: RPCBase) {
  return {
    getTurnStatus: () => {
      return this.send<{ Status: unknown }>("Nat.getTurnStatus").then(function (
        a
      ) {
        return a.params.Status;
      });
    },
    createP2PChannel: (Info: unknown) => {
      return this.send<{ Info: unknown }>("Nat.createP2PChannel", {
        Info: Info,
      }).then(function (a) {
        return a.params.Info;
      });
    },
    getTurnStatusByIndex: (params: object | object[] | null) => {
      return this.send<{ Status: unknown }>(
        "Nat.getTurnStatusByIndex",
        params
      ).then(function (a) {
        return a.params.Status;
      });
    },
  };
}



================================================
FILE: lib/rpc/NetApp.ts
================================================
import { RPCBase } from "../rpcBase";

export function NetApp(this: RPCBase) {
  return {
    getNetInterfaces: () => {
      return this.send<{
        netInterface: {
          ConnStatus: string;
          Name: string;
          NetCardName: string;
          PhysicalAddress: string;
          Speed: number;
          SupportLongPoE: boolean;
          Type: string;
          Valid: boolean;
        }[];
      }>("netApp.getNetInterfaces").then(function (a) {
        return a.params.netInterface;
      });
    },
    getMobileRSSI: (name: string) => {
      return this.send<{ info?: unknown }>("netApp.getMobileRSSI", {
        name: name,
      }).then(function (a) {
        return a.params.info || {};
      });
    },
    getMobileInterfaces: () => {
      return this.send<{ netInterface?: unknown }>(
        "netApp.getMobileInterfaces"
      ).then(function (a) {
        return a.params.netInterface || [];
      });
    },
    getNetDataStat: (Name: string) => {
      return this.send("netApp.getNetDataStat", { Name: Name }).then(function (
        a
      ) {
        return a.params;
      });
    },
    checkIPConflict: (Address: string, Interface: string) => {
      return this.send("netApp.checkIPConflict", {
        Interface: Interface || "eth0",
        Address: Address,
      })
        .then(function () {
          return !0;
        })
        .catch(function () {
          return !1;
        });
    },
    getNetCaps: () => {
      return this.send<{
        caps?: {
          Bond: number;
          DeviceDiscoveryPrivate: boolean;
          IEEE802_1X: boolean;
          P2P: {
            Support: boolean;
          };
          SupportHTTPS: boolean;
          SupportedMobilePush: boolean;
        };
      }>("netApp.getCaps").then(function (a) {
        return a.params.caps || {};
      });
    },
    getDialInfo: (Name: string) => {
      return this.send("netApp.getDialInfo", { Name: Name }).then(function (a) {
        return a.params;
      });
    },
    scanWLanDevices: (Name: string, SSID: string) => {
      return this.send<{ wlanDevice?: unknown }>("netApp.scanWLanDevices", {
        Name: Name,
        SSID: SSID,
      }).then(function (a) {
        return a.params.wlanDevice || [];
      });
    },
    getPppoeState: () => {
      return this.send<{ State: unknown }>("netApp.getPppoeState").then(
        function (a) {
          return a.params.State;
        }
      );
    },
    getPppoeIp: () => {
      return this.send<{ ipaddr: unknown }>("netApp.getPppoeIp").then(function (
        a
      ) {
        return a.params.ipaddr;
      });
    },
    getPppoeDns: () => {
      return this.send<{ ipaddr: unknown }>("netApp.getPppoeDns").then(
        function (a) {
          return a.params.ipaddr;
        }
      );
    },
    connectByWps: (
      Type: number,
      ApPin: string,
      SSID: string,
      WLanPin: string
    ) => {
      return this.send<{ info?: unknown }>("netApp.connectByWps", {
        info: { Type: Type, ApPin: ApPin, SSID: SSID, WLanPin: WLanPin },
      }).then(function (b) {
        return 1 === Type ? b.params.info : "";
      });
    },
    sendTestMail: () => {
      return this.send<{ result: boolean }>("netApp.sendTestMail").then(
        function (a) {
          return a.result;
        }
      );
    },
    getLinkStatus: (Name: string) => {
      return this.send("netApp.getLinkStatus", { Name: Name }).then(function (
        a
      ) {
        return a.params || {};
      });
    },
    getSIMState: (name: string) => {
      return this.send("mobile.getSIMState", { name: name }).then(function (a) {
        return a.params || {};
      });
    },
    getNetResourceStat: () => {
      return this.send<{
        IPChanneIn?: string;
        NetCapability?: string;
        NetRemain?: string;
        RemotePreview?: string;
        RemoteSendCapability?: string;
        RemoteSendRemain?: string;
      }>("netApp.getNetResourceStat").then(function (a) {
        return a.params || {};
      });
    },
  };
}



================================================
FILE: lib/rpc/OSDManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function OSDManager(this: RPCBase) {
  return {
    getCaps: () => {
      return this.send<{ caps: unknown }>("OSDManager.getCaps").then(function (
        a
      ) {
        return a.params.caps;
      });
    },
    getCustomCaps: () => {
      return this.send<{ caps: unknown }>("OSDManager.getCustomCaps").then(
        function (a) {
          return a.params.caps;
        }
      );
    },
  };
}



================================================
FILE: lib/rpc/PasswdFind.ts
================================================
import { RPCBase } from "../rpcBase";

export function PasswdFind(this: RPCBase) {
  return {
    getPub: () => {
      return this.sendRPC(
        this.rpc("Security.getEncryptInfo", null),
        "/OutsideCmd"
      ).then(function (a) {
        return a; // webApp.EncryptInfo || (webApp.EncryptInfo = a.params), a;
      });
    },
    getDescript: () => {
      return this.sendRPC(
        this.rpc("PasswdFind.getDescript", { name: "admin" }),
        "/OutsideCmd"
      ).then(function (a) {
        return a.params;
      });
    },
    resetPassword: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.sendRPC(
        this.rpc("PasswdFind.resetPassword", {
          salt: salt,
          cipher: cipher,
          content: content,
        }),
        "/OutsideCmd"
      ).then(function (a) {
        return a;
      });
    },
    setContact: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.send("PasswdFind.setContact", {
        salt: salt,
        cipher: cipher,
        content: content,
      });
    },
    getContact: (mode?: number) => {
      return this.send("PasswdFind.getContact", { mode: mode || 0 }).then(
        function (a) {
          return a.params;
        }
      );
    },
    checkAuthCode: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.sendRPC(
        this.rpc("PasswdFind.checkAuthCode", {
          salt: salt,
          cipher: cipher,
          content: content,
        }),
        "/OutsideCmd"
      ).then(function (a) {
        return a;
      });
    },
  };
}



================================================
FILE: lib/rpc/PeripheralChip.ts
================================================
import { RPCBase } from "../rpcBase";

export type Type = string;

export function PeripheralChip(this: RPCBase) {
  return {
    getCaps: () => {
      return this.send<{
        caps: Array<{
          chipType?: string;
          count: number;
          model?: string;
          type: Type;
        }>;
      }>("PeripheralChip.getCaps").then(function (a) {
        return a.params.caps;
      });
    },
    getVersion: (type: Type) => {
      return this.send<{
        versions: Array<{
          hardwareVersion: string;
          isMatching: number;
          softwareVersion: string;
        }>;
      }>("PeripheralChip.getVersion", { type: type }).then(function (a) {
        return a.params.versions;
      });
    },
  };
}



================================================
FILE: lib/rpc/PortraitFlowStat.ts
================================================
import { RPCBase } from "../rpcBase";

export function PortraitFlowStat(this: RPCBase) {
  return {
    getCaps: () => {
      return this.send<{ Caps: unknown }>("PortraitFlowStat.getCaps").then(
        function (a) {
          return a.params.Caps;
        }
      );
    },
    clearOSD: (channel?: number) => {
      return this.send("PortraitFlowStat.clearOSD", { channel: channel || 0 });
    },
  };
}



================================================
FILE: lib/rpc/PrivacyMasking.ts
================================================
import { RPCBase } from "../rpcBase";

export function PrivacyMasking(this: RPCBase) {
  return {
    getPrivacyMasking: (channel?: number, offset?: number, limit?: number) => {
      return this.send("PrivacyMasking.getPrivacyMasking", {
        channel: channel || 0,
        offset: offset || 0,
        limit: limit || 24,
      });
    },
    setPrivacyMasking: (channel?: number, PrivacyMasking?: unknown) => {
      return this.send("PrivacyMasking.setPrivacyMasking", {
        channel: channel || 0,
        PrivacyMasking: PrivacyMasking,
      });
    },
    getPrivacyMaskingEnable: (channel?: number) => {
      return this.send("PrivacyMasking.getPrivacyMaskingEnable", {
        channel: channel || 0,
      });
    },
    setPrivacyMaskingEnable: (channel?: number, Enable?: unknown) => {
      return this.send("PrivacyMasking.setPrivacyMaskingEnable", {
        channel: channel || 0,
        Enable: Enable,
      });
    },
    gotoPrivacyMasking: (channel?: number, index?: number) => {
      return this.send("PrivacyMasking.gotoPrivacyMasking", {
        channel: channel || 0,
        index: index || 0,
      });
    },
    deletePrivacyMasking: (channel?: number, index?: number) => {
      return this.send("PrivacyMasking.deletePrivacyMasking", {
        channel: channel || 0,
        index: index || 0,
      });
    },
    clearPrivacyMasking: (channel?: number) => {
      return this.send("PrivacyMasking.clearPrivacyMasking", {
        channel: channel || 0,
      });
    },
  };
}



================================================
FILE: lib/rpc/PTZ.ts
================================================
import { RPCBase } from "../rpcBase";

export function PTZ(this: RPCBase) {
  const _getSeq = () => {
    const a = this.getSession()
        .toString()
        .replace(/[^0-9]/gi, ""),
      c = parseInt(a).toString(2).slice(-24),
      d = ("00000000" + b.toString(2)).slice(-8);
    return (b = (b + 1) % 256), parseInt(c + d, 2);
  };

  const instance = this.sendSetup("ptz.factory.instance");
  let b = 0;

  return {
    instance,
    start: async (
      code: unknown,
      arg1: unknown,
      arg2: unknown,
      arg3: unknown,
      arg4: unknown,
      channel: number
    ) => {
      const g = await instance({ channel: channel || 0 });
      return await this.send(
        "ptz.start",
        { code: code, arg1: arg1, arg2: arg2, arg3: arg3, arg4: arg4 },
        { object: g.result, seq: _getSeq() }
      );
    },
    stop: (
      code: unknown,
      arg1: unknown,
      arg2: unknown,
      arg3: unknown,
      arg4: unknown,
      channel: number
    ) => {
      return instance({ channel: channel || 0 }).then((g) => {
        return this.send(
          "ptz.stop",
          { code: code, arg1: arg1, arg2: arg2, arg3: arg3, arg4: arg4 },
          { object: g.result, seq: _getSeq() }
        );
      });
    },
    getCurrentProtocolCaps: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ caps: unknown }>(
          "ptz.getCurrentProtocolCaps",
          void 0,
          {
            object: a.result,
          }
        ).then(function (a) {
          return a.params.caps;
        });
      });
    },
    getProtocolList: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<never, undefined | []>("ptz.getProtocolList", void 0, {
          object: a.result,
        }).then(function (a) {
          return a.result || [];
        });
      });
    },
    getProtocol: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ info: unknown }>("ptz.getProtocol", void 0, {
          object: a.result,
        }).then(function (a) {
          return a.params.info;
        });
      });
    },
    focusContinuously: (speed: unknown, timeout: unknown, channel: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.focusContinuously",
          { speed: speed, timeout: timeout },
          { object: c.result }
        );
      });
    },
    focusManually: (change: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.focusManually",
          { change: change },
          { object: b.result }
        );
      });
    },
    stopFocus: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("ptz.stopFocus", null, { object: a.result });
      });
    },
    adjustIris: (change: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.adjustIris",
          { change: change },
          { object: b.result }
        );
      });
    },
    auxControl: (func: unknown, open: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.auxControl",
          { function: func, open: open },
          { object: c.result }
        );
      });
    },
    menuControl: (key: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send("ptz.menuControl", { key: key }, { object: b.result });
      });
    },
    lensInit: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("ptz.lensInit", void 0, { object: a.result });
      });
    },
    restartCamera: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("ptz.restartCamera", void 0, { object: a.result });
      });
    },
    reset: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("ptz.reset", void 0, { object: a.result });
      });
    },
    restartPtz: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("ptz.restartPtz", void 0, { object: a.result });
      });
    },
    setPreset: (index: number, name: string, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.setPreset",
          { name: name, index: index },
          { object: c.result }
        );
      });
    },
    getPresets: (channel?: number, something?: boolean) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ presets?: { Type: number }[] }>(
          "ptz.getPresets",
          void 0,
          { object: a.result }
        ).then((a) => {
          let c = a.params.presets;
          const d = [2];
          if (something) return c;
          const e = [];
          c = c || [];
          for (let f = 0, g = c.length; g > f; f++)
            -1 == d.indexOf(c[f].Type) && e.push(c[f]);
          return e;
        });
      });
    },
    gotoPreset: (index: number, speed: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.gotoPreset",
          { speed: speed, index: index },
          { object: c.result }
        );
      });
    },
    removePreset: (index: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.removePreset",
          { index: index },
          { object: b.result }
        );
      });
    },
    setTour: (index: number, name: string, channel?: string) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.setTour",
          { name: name, index: index },
          { object: c.result }
        );
      });
    },
    getTours: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ tours: unknown }>("ptz.getTours", void 0, {
          object: a.result,
        }).then((a) => {
          return a.params.tours;
        });
      });
    },
    removeTour: (index?: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.removeTour",
          { index: index },
          { object: b.result }
        );
      });
    },
    startTour: (index: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.startTour",
          { index: index },
          { object: b.result }
        );
      });
    },
    stopTour: (index: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.stopTour",
          { index: index },
          { object: b.result }
        );
      });
    },
    autoTour: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("ptz.autoTour", void 0, { object: a.result });
      });
    },
    moveAbsolutely: (position: unknown, speed: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.moveAbsolutely",
          { position: position, speed: speed },
          { object: c.result }
        );
      });
    },
    moveRelatively: (translation: unknown, speed: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.moveRelatively",
          { translation: translation, speed: speed },
          { object: c.result }
        );
      });
    },
    moveDirectly: (screen: unknown, speed: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.moveDirectly",
          { screen: screen, speed: speed },
          { object: c.result }
        );
      });
    },
    moveContinuously: (speed: number, timeout: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((d) => {
        return this.send(
          "ptz.moveContinuously",
          { speed: speed, timeout: timeout },
          { object: d.result, seq: _getSeq() }
        );
      });
    },
    continueMoveDirectly: (
      index: number,
      timeInterval: number,
      isLastScreen: boolean,
      screen: unknown,
      channel?: number
    ) => {
      return instance({ channel: channel || 0 }).then((e) => {
        return this.send(
          "ptz.continueMoveDirectly",
          {
            screenDetail: {
              index: index,
              timeInterval: timeInterval,
              isLastScreen: isLastScreen,
            },
            screen: screen,
          },
          { object: e.result }
        );
      });
    },
    stopMove: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send("ptz.stopMove", void 0, {
          object: b.result,
          seq: _getSeq(),
        });
      });
    },
    isMoving: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ moving: unknown }>("ptz.isMoving", void 0, {
          object: a.result,
        }).then((a) => {
          return a.params.moving;
        });
      });
    },
    getStatus: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ status: unknown }>("ptz.getStatus", void 0, {
          object: a.result,
        }).then((a) => {
          return a.params.status;
        });
      });
    },
    focusRegion: (mode: unknown, rect: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.focusRegion",
          { mode: mode, rect: rect },
          { object: c.result }
        );
      });
    },
    setDirection: (direction: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.setDirection",
          { direction: direction },
          { object: b.result }
        );
      });
    },
    enableLimit: (enable: boolean, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.enableLimit",
          { enable: enable },
          { object: b.result }
        );
      });
    },
    markLimit: (type: string, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send("ptz.markLimit", { type: type }, { object: b.result });
      });
    },
    gotoLimit: (type: string, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send("ptz.gotoLimit", { type: type }, { object: b.result });
      });
    },
    setScanLimit: (index: number, limitMode: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.setScanLimit",
          { index: index, limitMode: limitMode },
          { object: c.result }
        );
      });
    },
    stopScan: (index: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.stopScan",
          { index: index },
          { object: b.result }
        );
      });
    },
    startScan: (index: number, speed: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.startScan",
          { index: index, speed: speed },
          { object: c.result }
        );
      });
    },
    stopPatternReplay: (index: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.stopPatternReplay",
          { index: index },
          { object: b.result }
        );
      });
    },
    startPatternReplay: (index: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.startPatternReplay",
          { index: index },
          { object: b.result }
        );
      });
    },
    stopPatternRecord: (index: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((b) => {
        return this.send(
          "ptz.stopPatternRecord",
          { index: index },
          { object: b.result }
        );
      });
    },
    startPatternRecord: (index: number, name: string, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.startPatternRecord",
          { index: index, name: name },
          { object: c.result }
        );
      });
    },
    moveAutoPan: (speed: number, timeout: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.moveAutoPan",
          { speed: speed, timeout: timeout },
          { object: c.result }
        );
      });
    },
    setStatisticPlan: (type: string, id: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.setStatisticPlan",
          { type: type, id: id },
          { object: c.result }
        );
      });
    },
    gotoStatisticPlan: (type: string, id: number, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.gotoStatisticPlan",
          { type: type, id: id },
          { object: c.result }
        );
      });
    },
    getLifetimeEncrypt: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ lifetime: unknown }>(
          "ptz.getLifetimeEncrypt",
          null,
          { object: a.result }
        ).then((a) => {
          return a.params.lifetime;
        });
      });
    },
    getOperationStatus: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ status: unknown }>("ptz.getOperationStatus", null, {
          object: a.result,
        }).then((a) => {
          return a.params.status;
        });
      });
    },
    getMotorSteps: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send<{ steps: unknown }>("ptz.getMotorSteps", null, {
          object: a.result,
        }).then((a) => {
          return a.params.steps;
        });
      });
    },
    setMotorSteps: (steps: unknown, speed: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((c) => {
        return this.send(
          "ptz.setMotorSteps",
          { steps: steps, speed: speed },
          { object: c.result }
        );
      });
    },
    directionCalibration: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("ptz.directionCalibration", void 0, {
          object: a.result,
        }).then((a) => {
          return a.params;
        });
      });
    },
    getViewRangeStatus: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("ptz.getViewRangeStatus", null, {
          object: a.result,
        }).then((a) => {
          return a;
        });
      });
    },
    getZoomValue: (channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send("ptz.getZoomValue", null, { object: a.result }).then(
          (a) => {
            return a.params;
          }
        );
      });
    },
  };
}



================================================
FILE: lib/rpc/PTZBase.ts
================================================
import { RPCBase } from "../rpcBase";

export function PTZBase(this: RPCBase) {
  return {
    moveContinuously: (
      speed: unknown,
      timeout: unknown,
      zoomSource: unknown,
      channel?: number
    ) => {
      return this.send("ptzBase.moveContinuously", {
        speed: speed,
        timeout: timeout,
        zoomSource: zoomSource,
        channel: channel || 0,
      });
    },
    getHFovValue: (zoom?: number, channel?: number) => {
      return this.send("ptzBase.getHFovValue", {
        channel: channel || 0,
        zoom: zoom || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    getCurrentFovValue: (channel?: number) => {
      return this.send("ptzBase.getCurrentFovValue", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    getFlipStatus: (channel?: number) => {
      return this.send("ptzBase.getFlipStatus", { channel: channel || 0 }).then(
        function (a) {
          return a.params;
        }
      );
    },
    autoFovCalibrate: (channel?: number) => {
      return this.send("ptzBase.autoFovCalibrate", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    getFovCalibrateStatus: (channel?: number) => {
      return this.send("ptzBase.getFovCalibrateStatus", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/PtzPeripheral.ts
================================================
import { RPCBase } from "../rpcBase";

export function PtzPeripheral(this: RPCBase) {
  return {
    clearFogStrongly: (channel?: number) => {
      return this.send("PtzPeripheral.clearFogStrongly", {
        channel: channel || 0,
      });
    },
    adjustLaserAxis: (channel?: number, speed?: unknown) => {
      return this.send("PtzPeripheral.adjustLaserAxis", {
        channel: channel || 0,
        speed: speed,
      });
    },
    stopAdjustLaserAxis: (channel?: number) => {
      return this.send("PtzPeripheral.stopAdjustLaserAxis", {
        channel: channel || 0,
      });
    },
    startClearFrost: (channel?: number) => {
      return this.send("PtzPeripheral.startClearFrost", {
        channel: channel || 0,
      });
    },
    stopClearFrost: (channel?: number) => {
      return this.send("PtzPeripheral.stopClearFrost", {
        channel: channel || 0,
      });
    },
    getHeaterStateEx: (channel?: number) => {
      return this.send("PtzPeripheral.getHeaterStateEx", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    controlPtzHeater: (time: unknown, channel?: number) => {
      return this.send("PtzPeripheral.controlPtzHeater", {
        time: time,
        channel: channel || 0,
      });
    },
  };
}



================================================
FILE: lib/rpc/PtzViewRange.ts
================================================
import { RPCBase } from "../rpcBase";

export function PtzViewRange(this: RPCBase) {
  const instance = this.sendSetup("ptzViewRange.factory.instance");
  return {
    instance,
    measureDistance: (channel: unknown, screenX: unknown, screenY: unknown) => {
      return this.send("PtzViewRange.measureDistance", {
        channel: channel,
        screenX: screenX,
        screenY: screenY,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/RainBrush.ts
================================================
import { RPCBase } from "../rpcBase";

export function RainBrush(this: RPCBase) {
  return {
    moveContinuously: (interval: unknown, channel?: number) => {
      return this.send("rainBrush.moveContinuously", {
        channel: channel || 0,
        interval: interval,
      });
    },
    stopMove: (channel?: number) => {
      return this.send("rainBrush.stopMove", { channel: channel || 0 });
    },
    moveOnce: (channel?: number) => {
      return this.send("rainBrush.moveOnce", { channel: channel || 0 });
    },
    washOnce: (channel?: number) => {
      return this.send("rainBrush.washOnce", { channel: channel || 0 });
    },
    rainfallSelfCheck: (channel?: number) => {
      return this.send("rainBrush.rainfallSelfCheck", {
        channel: channel || 0,
      });
    },
  };
}



================================================
FILE: lib/rpc/RecordFinder.ts
================================================
import { RPCBase } from "../rpcBase";

export function RecordFinder(this: RPCBase) {
  return {
    create: (name: unknown) => {
      // var b =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send("RecordFinder.factory.create", { name: name }).then(
        function (a) {
          return a.result;
        }
      );
    },
    startFind: (condition: unknown, object: unknown) => {
      // var c =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send(
        "RecordFinder.startFind",
        { condition: condition },
        { object: object }
      ).then(function (a) {
        return a;
      });
    },
    doFind: (count: unknown, object: unknown) => {
      // var c =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send(
        "RecordFinder.doFind",
        { count: count },
        { object: object }
      ).then(function (a) {
        return a;
      });
    },
    stopFind: (object: unknown) => {
      // var b =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send("RecordFinder.stopFind", null, { object: object }).then(
        function (a) {
          return a;
        }
      );
    },
    doSeekFind: (offset: unknown, count: unknown, object: unknown) => {
      // var d =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send(
        "RecordFinder.doSeekFind",
        { offset: offset, count: count },
        { object: object }
      ).then(function (a) {
        return a.params;
      });
    },
    destroy: (object: unknown) => {
      // var b =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send("RecordFinder.destroy", null, { object: object }).then(
        function (a) {
          return a;
        }
      );
    },
    getQuerySize: (object: unknown) => {
      // var b =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send("RecordFinder.getQuerySize", null, {
        object: object,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/RecordManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function RecordManager(this: RPCBase) {
  return {
    start: () => {
      return this.send("recordManager.start");
    },
    stop: () => {
      return this.send("recordManager.stop");
    },
    getCaps: () => {
      return this.send<{ caps: unknown }>("recordManager.getCaps").then(
        function (a) {
          return a.params.caps;
        }
      );
    },
    startChannel: (channel: unknown) => {
      return this.send("recordManager.startChannel", { channel: channel });
    },
    stopChannel: (channel: unknown) => {
      return this.send("recordManager.stopChannel", { channel: channel });
    },
    getState: (channel: unknown) => {
      return this.send<{ state?: boolean }>("recordManager.getState", {
        channel: channel,
      }).then(function (a) {
        return a.params.state || !1;
      });
    },
  };
}



================================================
FILE: lib/rpc/RecordUpdater.ts
================================================
import { RPCBase } from "../rpcBase";

export function RecordUpdater(this: RPCBase) {
  return {
    imports: (records: unknown, object: unknown) => {
      return this.send(
        "RecordUpdater.import",
        { records: records },
        { object: object }
      ).then(function (a) {
        return a;
      });
    },
    instance: (name: unknown) => {
      // var b =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send("RecordUpdater.factory.instance", { name: name }).then(
        function (a) {
          return a;
        }
      );
    },
    insert: (record: unknown, object: unknown) => {
      // var c =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send(
        "RecordUpdater.insert",
        { record: record },
        { object: object }
      ).then(function (a) {
        return a;
      });
    },
    remove: (recno: unknown, object: unknown) => {
      // var c =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send(
        "RecordUpdater.remove",
        { recno: recno },
        { object: object }
      ).then(function (a) {
        return a;
      });
    },
    update: (recno: unknown, record: unknown, object: unknown) => {
      // var d =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send(
        "RecordUpdater.update",
        { recno: recno, record: record },
        { object: object }
      ).then(function (a) {
        return a;
      });
    },
    clear: (object: unknown) => {
      // var b =
      //   webApp.EncryptInfo && webApp.EncryptInfo.asymmetric
      //     ? l.sendSec
      //     : this.send;
      return this.send("RecordUpdater.clear", null, { object: object });
    },
    importFile: (
      filename: unknown,
      format: unknown,
      code: unknown,
      object: unknown
    ) => {
      return this.send(
        "RecordUpdater.importFile",
        { filename: filename, format: format, code: code },
        { object: object }
      ).then(function (a) {
        return a;
      });
    },
    exportFile: (
      filename: unknown,
      format: unknown,
      code: unknown,
      object: unknown
    ) => {
      return this.send(
        "RecordUpdater.exportFile",
        { filename: filename, format: format, code: code },
        { object: object }
      ).then(function (a) {
        return a;
      });
    },
    // importFileEncrypt: (a, b, c, d, e) => {
    //   return this.sendSec(
    //     "RecordUpdater.importFileEncrypt",
    //     {
    //       filename: a,
    //       format: b,
    //       code: c,
    //       encrypt: { scheme: "AES", key: d },
    //     },
    //     { object: e }
    //   )
    //     .then(function (a) {
    //       return a.params;
    //     });
    // },
    // exportFileEncrypt: (a, b, c, d, e, f) => {
    //   return this.sendSec(
    //     "RecordUpdater.exportFileEncrypt",
    //     {
    //       filename: a,
    //       format: b,
    //       code: c,
    //       encrypt: { scheme: "AES", key: d },
    //       isBlock: e,
    //     },
    //     { object: f }
    //   )
    //     .then(function (a) {
    //       return a.params;
    //     });
    // },
    exportAsyncFile: (
      filename: unknown,
      format: unknown,
      code: unknown,
      object: unknown
    ) => {
      return this.send(
        "RecordUpdater.exportAsyncFile",
        { filename: filename, format: format, code: code },
        { object: object }
      ).then(function (a) {
        return a;
      });
    },
    getFileImportState: (object: unknown) => {
      return this.send("RecordUpdater.getFileImportState", null, {
        object: object,
      }).then(function (a) {
        return a;
      });
    },
    getFileImportData: (object: unknown) => {
      return this.send("RecordUpdater.getFileImportData", null, {
        object: object,
      }).then(function (a) {
        return a;
      });
    },
    getFileExportState: (object: unknown) => {
      return this.send("RecordUpdater.getFileExportState", null, {
        object: object,
      }).then(function (a) {
        return a;
      });
    },
    getSchema: (object: unknown) => {
      return this.send("RecordUpdater.getSchema", null, {
        object: object,
      }).then(function (a) {
        return a;
      });
    },
  };
}



================================================
FILE: lib/rpc/RemoteUpgrader.ts
================================================
import { RPCBase } from "../rpcBase";

export function RemoteUpgrader(this: RPCBase) {
  return {
    selectDevList: (list: unknown) => {
      return this.send("RemoteUpgrader.selectDevList", { list: list }).then(
        function (a) {
          return a.params ? a.params : a;
        }
      );
    },
    getAllStates: () => {
      return this.send("RemoteUpgrader.getAllStates").then(function (a) {
        return a.params ? a.params : a;
      });
    },
    cancel: () => {
      return this.send("RemoteUpgrader.cancel", { list: ["All"] }).then(
        function (a) {
          return a.params ? a.params : a;
        }
      );
    },
  };
}



================================================
FILE: lib/rpc/RfidManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function RfidManager(this: RPCBase) {
  return {
    getSignalThreshold: () => {
      return this.send<{ signalThreshold: unknown }>(
        "RfidManager.getSignalThreshold"
      ).then(function (a) {
        return a.params.signalThreshold;
      });
    },
    setSignalThreshold: (signalThreshold: unknown) => {
      return this.send("RfidManager.setSignalThreshold", {
        signalThreshold: signalThreshold,
      }).then(function (a) {
        return a.params;
      });
    },
    getVersion: () => {
      return this.send<{ version: unknown }>("RfidManager.getVersion").then(
        function (a) {
          return a.params.version;
        }
      );
    },
    getReceiverID: () => {
      return this.send<{ receiverID: unknown }>(
        "RfidManager.getReceiverID"
      ).then(function (a) {
        return a.params.receiverID;
      });
    },
  };
}



================================================
FILE: lib/rpc/ScenicSpot.ts
================================================
import { RPCBase } from "../rpcBase";

export function ScenicSpot(this: RPCBase) {
  return {
    getCaps: (channel?: unknown) => {
      return this.send<{ caps: unknown }>("ScenicSpot.getCaps", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params.caps;
      });
    },
  };
}



================================================
FILE: lib/rpc/SDEncrypt.ts
================================================
import { RPCBase } from "../rpcBase";

export function SDEncrypt(this: RPCBase) {
  return {
    encrypt: (name: unknown, password: unknown) => {
      return this.send("SDEncrypt.encrypt", { name: name, password: password });
    },
    decrypt: (name: unknown, password: unknown) => {
      return this.send("SDEncrypt.decrypt", { name: name, password: password });
    },
    modifyPassword: (
      name: unknown,
      password: unknown,
      oldPassword: unknown
    ) => {
      return this.send("SDEncrypt.modifyPassword", {
        name: name,
        password: password,
        oldPassword: oldPassword,
      });
    },
    clearPassword: (name: unknown, password: unknown) => {
      return this.send("SDEncrypt.clearPassword", {
        name: name,
        password: password,
      });
    },
    getOperateErrorPolicy: (name: unknown, operate: unknown) => {
      return this.send("SDEncrypt.getOperateErrorPolicy", {
        name: name,
        operate: operate,
      });
    },
  };
}



================================================
FILE: lib/rpc/Security.ts
================================================
import { RPCBase } from "../rpcBase";

export function Security(this: RPCBase) {
  return {
    getEncryptInfo: () => {
      return this.send("Security.getEncryptInfo").then(function (a) {
        return a.params;
      });
    },
    getEncryptDog: () => {
      return this.send<{ info: unknown }>("Security.getEncryptDog").then(
        function (a) {
          return a.params.info;
        }
      );
    },
    addUser: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.send("Security.addUser", {
        salt: salt,
        cipher: cipher,
        content: content,
      });
    },
    addUserPlain: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.send("Security.addUserPlain", {
        salt: salt,
        cipher: cipher,
        content: content,
      });
    },
    modifyPasswordByType: (
      salt: unknown,
      cipher: unknown,
      content: unknown
    ) => {
      return this.send("Security.modifyPasswordByType", {
        salt: salt,
        cipher: cipher,
        content: content,
      });
    },
    modifyPasswordPlain: (a: unknown, b: unknown, c: unknown) => {
      return this.send("Security.modifyPasswordPlain", {
        salt: a,
        cipher: b,
        content: c,
      });
    },
    ModifyPwdOutSession: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.sendRPC(
        this.rpc("Security.modifyPwdOutSession", {
          salt: salt,
          cipher: cipher,
          content: content,
        }),
        "/OutsideCmd"
      ).then(function (a) {
        return a.params;
      });
    },
    getConfig: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.send<{ content: unknown }>("Security.getConfig", {
        salt: salt,
        cipher: cipher,
        content: content,
      }).then(function (a) {
        return a.params.content;
      });
    },
    setConfig: (salt: unknown, cipher: unknown, content: unknown) => {
      return this.send<{ content: unknown } | null>("Security.setConfig", {
        salt: salt,
        cipher: cipher,
        content: content,
      }).then(function (a) {
        return a.params && a.params.content;
      });
    },
  };
}



================================================
FILE: lib/rpc/SnapManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function SnapManager(this: RPCBase) {
  return {
    start: () => {
      return this.send("snapManager.start");
    },
    stop: () => {
      return this.send("snapManager.stop");
    },
    getCaps: () => {
      return this.send<{
        caps: {
          SupportSnapSchedule?: boolean;
          SupportSnapshotByJsonEvent?: boolean;
          TransferOffline?: {
            Enable: boolean;
          };
          SupportFtpPathMode?: boolean;
        };
      }>("snapManager.getCaps").then(function (a) {
        return a.params.caps;
      });
    },
    manualUploadPicture: (params: object | object[] | null) => {
      return this.send("snapManager.manualUploadPicture", params).then(
        function (a) {
          return a;
        }
      );
    },
    getOfflineUploadInfo: (TargetType: unknown) => {
      return this.send("snapManager.getOfflineUploadInfo", {
        TargetType: TargetType,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/Speak.ts
================================================
import { RPCBase } from "../rpcBase";

export function Speak(this: RPCBase) {
  return {
    startPlay: (path: unknown) => {
      return this.send<{ Status: unknown }>("speak.startPlay", {
        path: path,
      }).then(function (a) {
        return a.params.Status;
      });
    },
    stopPlay: () => {
      return this.send("speak.stopPlay");
    },
    getCaps: () => {
      return this.send<{ caps: unknown }>("speak.getCaps").then(function (a) {
        return a.params.caps;
      });
    },
  };
}



================================================
FILE: lib/rpc/Storage.ts
================================================
import { RPCBase } from "../rpcBase";

export function Storage(this: RPCBase) {
  const instance = this.sendSetup("storage.getDevice");
  const getDevice = (name: string) => {
    return this.send("storage.getDevice", { name: name }).then(function (a) {
      return a.result;
    });
  };

  return {
    instance,
    getCaps: () => {
      return this.send<{ caps: unknown }>("storage.getCaps").then(function (a) {
        return a.params.caps;
      });
    },
    testNAS: (a: unknown) => {
      return this.send("storage.testNAS", { NAS: a }).then(function (a) {
        return a.result;
      });
    },
    getPortInfo: () => {
      return this.send<{ info?: unknown }>("storage.getPortInfo").then(
        function (a) {
          return a.params.info || {};
        }
      );
    },
    getBoundTimeEx: (DiskList: unknown) => {
      return this.send<{ time?: unknown }>("storage.getBoundTimeEx", {
        DiskList: DiskList,
      }).then(function (a) {
        return a.params.time || [];
      });
    },
    getDeviceNames: () => {
      return this.send<{ list: string | null }>("storage.getDeviceNames").then(
        function (a) {
          return a.params.list;
        }
      );
    },
    getDevice,
    getDeviceInfo: (name: string) => {
      getDevice(name).then((pointer) => {
        return this.send<{ device: unknown }>("devStorage.getDeviceInfo", {
          pointer: pointer,
        }).then(function (a) {
          return a.params.device;
        });
      });
    },
    getDirectory: (path: string) => {
      return this.send("storage.getDirectory", { path: path }).then(function (
        a
      ) {
        return a.result;
      });
    },
  };
}



================================================
FILE: lib/rpc/StreamUrlService.ts
================================================
import { RPCBase } from "../rpcBase";

export function StreamUrlService(this: RPCBase) {
  return {
    getUrls: (protocol: string, type: unknown, streamopt: unknown) => {
      return this.send("StreamUrlService.getUrls", {
        protocol: protocol,
        type: type,
        streamopt: streamopt,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/System.ts
================================================
import { RPCBase } from "../rpcBase";

export function System(this: RPCBase) {
  return {
    // multiSec: (salt: unknown, content: unknown) => {
    //   return this.send<{ content: unknown }>("system.multiSec", { cipher: i(), salt: salt, content: content })
    //     .then(function (a) {
    //       return a.params.content;
    //     });
    // },
    // attachSec: (salt: unknown, content: unknown) => {
    //   return this.send<{ content: unknown }>("system.attachSec", { cipher: i(), salt: salt, content: content })
    //     .then(function (a) {
    //       return a.params.content;
    //     });
    // },
    // detachSec: (SID: unknown, salt: unknown, content: unknown) => {
    //   return this.send<{ content: unknown }>("system.detachSec", {
    //     SID: SID,
    //     cipher: i(),
    //     salt: salt,
    //     content: content,
    //   })
    //     .then(function (a) {
    //       return a.params.content;
    //     });
    // },
  };
}



================================================
FILE: lib/rpc/TemperCorrection.ts
================================================
import { RPCBase } from "../rpcBase";

export function TemperCorrection(this: RPCBase) {
  return {
    adjustBlkBdyDist: (Info: {
      Index: unknown;
      BackgroundTemp: unknown;
      BlkBdyTemp: unknown;
      HoleSize: unknown;
      Distance: unknown;
    }) => {
      return this.send<{ graveAve: unknown }>(
        "TemperCorrection.adjustBlkBdyDist",
        {
          Info: {
            Index: Info.Index,
            BackgroundTemp: Info.BackgroundTemp,
            BlkBdyTemp: Info.BlkBdyTemp,
            HoleSize: Info.HoleSize,
            Distance: Info.Distance,
          },
        }
      ).then(function (a) {
        return a.params.graveAve;
      });
    },
    getNucInfo: (channel: unknown) => {
      return this.send<{ info: unknown }>("TemperCorrection.getNucInfo", {
        channel: channel,
      }).then(function (a) {
        return a.params.info;
      });
    },
    setNucInfo: (channel: unknown, info: unknown) => {
      return this.send("TemperCorrection.setNucInfo", {
        channel: channel,
        info: info,
      });
    },
    getNucStableStatus: (channel: unknown) => {
      return this.send<{ status: unknown }>(
        "TemperCorrection.getNucStableStatus",
        { channel: channel }
      ).then(function (a) {
        return a.params.status;
      });
    },
    getRmcInfo: (channel: unknown) => {
      return this.send<{ info: unknown }>("TemperCorrection.getRmcInfo", {
        channel: channel,
      }).then(function (a) {
        return a.params.info;
      });
    },
    BlkBdySampAdd: (channel: unknown, info: unknown) => {
      return this.send("TemperCorrection.BlkBdySampAdd", {
        channel: channel,
        info: info,
      });
    },
    BlkBdySampDel: (channel: unknown, info: unknown) => {
      return this.send("TemperCorrection.BlkBdySampDel", {
        channel: channel,
        info: info,
      });
    },
    checkSamp: (channel: unknown, amID: unknown) => {
      return this.send<{ info: unknown }>("TemperCorrection.checkSamp", {
        channel: channel,
        amID: amID,
      }).then(function (a) {
        return a.params.info;
      });
    },
    getRmcRes: (channel: unknown) => {
      return this.send<{ info: unknown }>("TemperCorrection.getRmcRes", {
        channel: channel,
      }).then(function (a) {
        return a.params.info;
      });
    },
    userTemperCal: (
      channel: unknown,
      objTemper: unknown,
      coordinate: unknown
    ) => {
      return this.send("TemperCorrection.userTemperCal", {
        channel: channel,
        objTemper: objTemper,
        coordinate: coordinate,
      }).then(function (a) {
        return a.params;
      });
    },
    getBadColManualParam: (channel: unknown) => {
      return this.send<{ info: unknown }>(
        "TemperCorrection.getBadColManualParam",
        { channel: channel }
      ).then(function (a) {
        return a.params.info;
      });
    },
    setBadColManualParam: (
      channel: unknown,
      Enable: unknown,
      BadCols: unknown
    ) => {
      return this.send("TemperCorrection.setBadColManualParam", {
        channel: channel,
        info: { Enable: Enable, BadCols: BadCols },
      }).then(function (a) {
        return a.params;
      });
    },
    getRadioSensorParam: (channel: unknown) => {
      return this.send<{ info: unknown }>(
        "TemperCorrection.getRadioSensorParam",
        { channel: channel }
      ).then(function (a) {
        return a.params.info;
      });
    },
    setRadioSensorParam: (channel: unknown, info: unknown) => {
      return this.send<{ info: unknown }>(
        "TemperCorrection.setRadioSensorParam",
        {
          channel: channel,
          info: info,
        }
      ).then(function (a) {
        return a.params;
      });
    },
    getHistValueDirectly: (channel: unknown) => {
      return this.send<{ info: unknown }>(
        "TemperCorrection.getHistValueDirectly",
        { channel: channel }
      ).then(function (a) {
        return a.params.info;
      });
    },
    getRadioGrayPointInfo: (
      channel: unknown,
      pointType: unknown,
      location: unknown
    ) => {
      return this.send<{ info: unknown }>(
        "TemperCorrection.getRadioGrayPointInfo",
        {
          channel: channel,
          pointType: pointType,
          location: location,
        }
      ).then(function (a) {
        return a.params.info;
      });
    },
    getThermoReceptorParam: (channel: unknown) => {
      return this.send<{ info: unknown }>(
        "TemperCorrection.getThermoReceptorParam",
        { channel: channel }
      ).then(function (a) {
        return a.params.info;
      });
    },
    getRadioGreyDiffParam: (channel: unknown, type: unknown) => {
      return this.send<{ info: unknown }>(
        "TemperCorrection.getRadioGreyDiffParam",
        {
          channel: channel,
          type: type,
        }
      ).then(function (a) {
        return a.params.info;
      });
    },
    setRadioGreyDiffParam: (
      channel: unknown,
      Type: unknown,
      GreyDiffData: unknown
    ) => {
      return this.send("TemperCorrection.setRadioGreyDiffParam", {
        channel: channel,
        info: { Type: Type, GreyDiffData: GreyDiffData },
      }).then(function (a) {
        return a.params;
      });
    },
    startAutoSaveGrayInfo: (
      channel: unknown,
      period: unknown,
      type: unknown
    ) => {
      return this.send("TemperCorrection.startAutoSaveGrayInfo", {
        channel: channel,
        period: period,
        type: type,
      }).then(function (a) {
        return a.params;
      });
    },
    getGrayInfoTable: (channel: unknown, startIndex: unknown) => {
      return this.send("TemperCorrection.getGrayInfoTable", {
        channel: channel,
        startIndex: startIndex,
        count: 100,
      }).then(function (a) {
        return a.params;
      });
    },
    setMechanismVersion: (channel: unknown, mechanismType: unknown) => {
      return this.send("TemperCorrection.setMechanismVersion", {
        channel: channel,
        mechanismType: mechanismType,
      }).then(function (a) {
        return a.params;
      });
    },
    getAutoTimerState: (channel: unknown) => {
      return this.send("TemperCorrection.getAutoTimerState", {
        channel: channel,
      }).then(function (a) {
        return a.params;
      });
    },
    clearDataAutoCollectParam: (channel: unknown) => {
      return this.send("TemperCorrection.clearDataAutoCollectParam", {
        channel: channel,
      }).then(function (a) {
        return a.params;
      });
    },
    restoreCam: (channel: unknown) => {
      return this.send("TemperCorrection.restoreCam", {
        channel: channel,
      }).then(function (a) {
        return a.result;
      });
    },
    getRicfTempMode: (channel: unknown) => {
      return this.send("TemperCorrection.getRicfTempMode", {
        channel: channel,
      }).then(function (a) {
        return a.params;
      });
    },
    setRicfTempMode: (
      channel: unknown,
      info: { TemperatureType: unknown; RicfMode: unknown }
    ) => {
      return this.send("TemperCorrection.setRicfTempMode", {
        channel: channel,
        info: {
          TemperatureType: info.TemperatureType,
          RicfMode: info.RicfMode,
        },
      }).then(function (a) {
        return a.params;
      });
    },
    setRifcBadPtAction: (Channel: unknown, OpType: unknown) => {
      return this.send("TemperCorrection.setRifcBadPtAction", {
        Channel: Channel,
        OpType: OpType,
      }).then(function (a) {
        return a.params;
      });
    },
    setRifcBadPtCheck: (Channel: unknown, CheckValue: unknown) => {
      return this.send("TemperCorrection.setRifcBadPtCheck", {
        Channel: Channel,
        CheckValue: CheckValue,
      }).then(function (a) {
        return a.params;
      });
    },
    getRealTimeBprStatus: (Channel: unknown) => {
      return this.send("TemperCorrection.getRealTimeBprStatus", {
        Channel: Channel,
      }).then(function (a) {
        return a.params;
      });
    },
    setRealTimeBprStatus: (Channel: unknown, Status: unknown) => {
      return this.send("TemperCorrection.setRealTimeBprStatus", {
        Channel: Channel,
        Status: Status,
      }).then(function (a) {
        return a.params;
      });
    },
    getCaps: (Channel: unknown) => {
      return this.send("TemperCorrection.getCaps", { Channel: Channel }).then(
        function (a) {
          return a.params;
        }
      );
    },
    getFpaNum: (Channel: unknown) => {
      return this.send("TemperCorrection.getFpaNum", { Channel: Channel }).then(
        function (a) {
          return a.params;
        }
      );
    },
    setFpaNum: (Channel: unknown, FpaNum: unknown) => {
      return this.send("TemperCorrection.setFpaNum", {
        Channel: Channel,
        FpaNum: FpaNum,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/ThermographyLog.ts
================================================
import { RPCBase } from "../rpcBase";

export function ThermographyLog(this: RPCBase) {
  const instance = this.sendSetup("log.factory.instance");
  return {
    instance,
    startFind: (condition: unknown) => {
      return instance({ type: "ThermoLog" }).then((b) => {
        return this.send<{ token: unknown }>(
          "log.startFind",
          { condition: condition },
          { object: b.result }
        ).then(function (a) {
          return a.params.token;
        });
      });
    },
    getCount: (token: unknown) => {
      return new Promise((resolve, reject) => {
        return instance({ type: "ThermoLog" }).then((c) => {
          return this.send<{ count: unknown }>(
            "log.getCount",
            { token: token },
            { object: c.result }
          )
            .then(function (b) {
              "number" === typeof b.params.count
                ? resolve(b.params.count)
                : reject();
            })
            .catch(reject);
        });
      });
    },
    doSeekFind: (token: unknown, offset: unknown, count: unknown) => {
      return instance({ type: "ThermoLog" }).then((d) => {
        return this.send(
          "log.doSeekFind",
          { token: token, offset: offset, count: count },
          { object: d.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
    stopFind: (token: unknown) => {
      return instance({ type: "ThermoLog" }).then((b) => {
        return this.send(
          "log.stopFind",
          { token: token },
          { object: b.result }
        );
      });
    },
    clear: (a?: { type?: unknown }) => {
      return instance({ type: "ThermoLog" }).then(
        a && a.type
          ? (b) => {
              return this.send(
                "log.clearByTypes",
                { Types: [a.type] },
                { object: b.result }
              ).then(function (a) {
                return a;
              });
            }
          : (a) => {
              return this.send("log.clear", { object: a.result }).then(
                function (a) {
                  return a;
                }
              );
            }
      );
    },
  };
}



================================================
FILE: lib/rpc/ThermoPrivateParam.ts
================================================
import { RPCBase } from "../rpcBase";

export function ThermoPrivateParam(this: RPCBase) {
  return {
    getCaps: (Channel: unknown) => {
      return this.send<{ Caps: unknown }>("ThermoPrivateParam.getCaps", {
        Channel: Channel,
      }).then(function (a) {
        return a.params.Caps;
      });
    },
  };
}



================================================
FILE: lib/rpc/trafficFlowStat.ts
================================================
import { RPCBase } from "../rpcBase";

export function trafficFlowStat(this: RPCBase) {
  return {
    getCaps: () => {
      return this.send<{ caps: unknown }>("trafficFlowStat.getCaps").then(
        function (a) {
          return a.params.caps;
        }
      );
    },
    startFind: (condition: unknown) => {
      return this.send("trafficFlowStat.startFind", {
        condition: condition,
      }).then(function (a) {
        return a.params;
      });
    },
    doFind: (token: unknown, count: unknown, begin?: number) => {
      return this.send("trafficFlowStat.doFind", {
        token: token,
        count: count,
        begin: begin || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    stopFind: (token: unknown) => {
      return this.send("trafficFlowStat.stopFind", { token: token });
    },
    clearStat: (
      channel?: number,
      lane?: number,
      presetID?: number,
      type?: number
    ) => {
      const e: {
        channel: number;
        lane: number;
        presetID?: number;
        type?: number;
      } = { channel: void 0 !== channel ? channel : -1, lane: lane || -1 };
      return (
        void 0 !== presetID && (e.presetID = presetID),
        void 0 !== type && (e.type = type),
        this.send("trafficFlowStat.clearStat", e).then(function (a) {
          return a.params;
        })
      );
    },
  };
}



================================================
FILE: lib/rpc/TrafficSnap.ts
================================================
import { RPCBase } from "../rpcBase";

export function TrafficSnap(this: RPCBase) {
  const instance = this.sendSetup("trafficSnap.factory.instance");
  return {
    instance,
    openStrobe: (openType: unknown, plateNumber: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "trafficSnap.openStrobe",
          { info: { openType: openType, plateNumber: plateNumber } },
          { object: a.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/TrafficStatistic.ts
================================================
import { RPCBase } from "../rpcBase";

export function TrafficStatistic(this: RPCBase) {
  return {
    startFind: (Condition: unknown) => {
      return this.send("TrafficStatistic.startFind", {
        Condition: Condition,
      }).then(function (a) {
        return a.params;
      });
    },
    doFind: (Token: unknown, BeginNumber: unknown, Count: unknown) => {
      return this.send("TrafficStatistic.doFind", {
        Token: Token,
        BeginNumber: BeginNumber,
        Count: Count,
      }).then(function (a) {
        return a.params;
      });
    },
    stopFind: (Token: unknown) => {
      return this.send("TrafficStatistic.stopFind", { Token: Token }).then(
        function (a) {
          return a;
        }
      );
    },
  };
}



================================================
FILE: lib/rpc/Upgrader.ts
================================================
import { RPCBase } from "../rpcBase";

export function Upgrader(this: RPCBase) {
  const instance = this.sendSetup("upgrader.factory.instance");
  const getState = () => {
    return this.send("upgrader.getState").then(function (a) {
      return a.params;
    });
  };

  return {
    instance,
    getStateEx: () => {
      return instance()
        .then((a) => {
          return this.send("upgrader.getState", null, {
            object: a.result,
          }).then(function (a) {
            return a.params;
          });
        })
        .catch(() => getState());
    },
    getState,
    check: () => {
      return this.send("upgrader.check").then(function (a) {
        return a.params;
      });
    },
    start: () => {
      return this.send("upgrader.start").then(function (a) {
        return a.params;
      });
    },
    cancel: () => {
      return this.send("upgrader.cancel").then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/UpgraderInstall.ts
================================================
import { RPCBase } from "../rpcBase";

export function UpgraderInstall(this: RPCBase) {
  return {
    prepare: () => {
      return this.send("upgraderInstall.prepare", null);
    },
    appendData: (length: unknown, totalLength: unknown) => {
      return this.send("upgraderInstall.appendData", {
        length: length,
        totalLength: totalLength,
      });
    },
    cancel: () => {
      return this.send("upgraderInstall.cancel", null);
    },
    execute: (autoReboot: unknown) => {
      return this.send("upgraderInstall.execute", { autoReboot: autoReboot });
    },
    getState: () => {
      return this.send("upgraderInstall.getState", null);
    },
    start: () => {
      return this.send("upgraderInstall.start", null);
    },
  };
}



================================================
FILE: lib/rpc/UPnPPortmap.ts
================================================
import { RPCBase } from "../rpcBase";

export function UPnPPortmap(this: RPCBase) {
  return {
    refreshUpnpRouter: () => {
      return this.send("UPnPPortmap.refreshUpnpRouter");
    },
    getUPnPStatus: () => {
      return this.send<{ status: unknown }>("UPnPPortmap.getUPnPStatus").then(
        function (a) {
          return a.params.status;
        }
      );
    },
    getRouterMapping: () => {
      return this.send<{ mapping: unknown }>(
        "UPnPPortmap.getRouterMapping"
      ).then(function (a) {
        return a.params.mapping;
      });
    },
  };
}



================================================
FILE: lib/rpc/UserManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function UserManager(this: RPCBase) {
  return {
    getActiveUserInfoAll: () => {
      return this.send<{ users?: unknown[] }>(
        "userManager.getActiveUserInfoAll"
      ).then(function (a) {
        return a.params.users || [];
      });
    },
    getUserInfo: (name: string) => {
      return this.send<{ user: unknown }>("userManager.getUserInfo", {
        name: name,
      }).then(function (a) {
        return a.params.user;
      });
    },
    getAuthorityList: () => {
      return this.send("userManager.getAuthorityList").then(function (a) {
        return a.params;
      });
    },
    addUser: (user: string) => {
      return this.send("userManager.addUser", { user: user });
    },
    addUserPlain: (user: string) => {
      return this.send("userManager.addUserPlain", { user: user });
    },
    deleteUser: (user: string) => {
      return this.send("userManager.deleteUser", { name: user });
    },
    modifyPassword: (name: string, pwd: string, pwdOld: string) => {
      return this.send("userManager.modifyPassword", {
        name: name,
        pwd: pwd,
        pwdOld: pwdOld,
      });
    },
    modifyUser: (name: string, user: unknown) => {
      return this.send("userManager.modifyUser", { name: name, user: user });
    },
    addGroup: (group: unknown) => {
      return this.send("userManager.addGroup", { group: group });
    },
    deleteGroup: (name: string) => {
      return this.send("userManager.deleteGroup", { name: name });
    },
    modifyGroup: (name: string, group: unknown) => {
      return this.send("userManager.modifyGroup", { name: name, group: group });
    },
    getUserInfoAll: () => {
      return this.send<{ users: unknown }>("userManager.getUserInfoAll").then(
        function (a) {
          return a.params.users;
        }
      );
    },
    getPwdValidPeriod: (name: string) => {
      return this.send("userManager.getPwdValidPeriod", { name: name }).then(
        function (a) {
          return a.params;
        }
      );
    },
    getGroupInfoAll: () => {
      return this.send("userManager.getGroupInfoAll").then(function (a) {
        return a.params;
      });
    },
    getErrorNo: () => {
      return this.send<{ error: unknown }>("userManager.getErrorNo").then(
        function (a) {
          return a.params.error;
        }
      );
    },
    onvifaddUser: (user: unknown) => {
      return this.send("userManager.onvifaddUser", { user: user });
    },
    onvifdeleteUser: (name: string) => {
      return this.send("userManager.onvifdeleteUser", { name: name });
    },
    onvifmodifyPassword: (name: string, pwd: string, pwdOld: string) => {
      return this.send("userManager.onvifmodifyPassword", {
        name: name,
        pwd: pwd,
        pwdOld: pwdOld,
      });
    },
    onvifmodifyUser: (name: string, user: unknown) => {
      return this.send("userManager.onvifmodifyUser", {
        name: name,
        user: user,
      });
    },
    getCaps: () => {
      return this.send<{ caps: object }>("userManager.getCaps").then(function (
        a
      ) {
        return a.params.caps || {};
      });
    },
    // attach: (proc: any) => {
    //   return this.sendattachSec("userManager.attachRefreshToken", { proc: proc })
    //     .then(function (a) {
    //       return a && a.params;
    //     });
    // },
    // detach: (SID: any, proc: any) => {
    //   return this.senddetachSec("userManager.detachRefreshToken", {
    //     SID: SID,
    //     proc: proc,
    //   });
    // }
  };
}



================================================
FILE: lib/rpc/UWB.ts
================================================
import { RPCBase } from "../rpcBase";

export function UWB(this: RPCBase) {
  return {
    recvMsg: () => {
      return this.send<{ param: unknown }>("UWB.recvMsg").then(function (a) {
        return a.params.param;
      });
    },
    sendMsg: (params: object | object[] | null) => {
      return this.send("UWB.sendMsg", params).then(function (a) {
        return a.result;
      });
    },
    rebootMcu: () => {
      return this.send("UWB.rebootMcu").then(function (a) {
        return a.result;
      });
    },
    resetMcu: () => {
      return this.send("UWB.resetMcu").then(function (a) {
        return a.result;
      });
    },
  };
}



================================================
FILE: lib/rpc/vehiclesDistribution.ts
================================================
import { RPCBase } from "../rpcBase";

export function vehiclesDistribution(this: RPCBase) {
  return {
    getRealTimeVehiclesInfoByRegion: (Region: unknown, Channel?: number) => {
      return this.send<{ VehiclesInfo: unknown }>(
        "vehiclesDistribution.getRealTimeVehiclesInfoByRegion",
        {
          Channel: Channel || 0,
          Region: Region,
        }
      ).then(function (a) {
        return a.params.VehiclesInfo;
      });
    },
  };
}



================================================
FILE: lib/rpc/videoCalibrateServer.ts
================================================
import { RPCBase } from "../rpcBase";

export function videoCalibrateServer(this: RPCBase) {
  return {
    checkCalibrate: (
      Class: unknown,
      CalibrateType: unknown,
      CheckParam: unknown,
      Channel: unknown
    ) => {
      return this.send("videoCalibrateServer.checkCalibrate", {
        Channel: Channel,
        Class: Class,
        CalibrateType: CalibrateType,
        CheckParam: CheckParam,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/VideoInAnalyse.ts
================================================
import { RPCBase } from "../rpcBase";

export function VideoInAnalyse(this: RPCBase) {
  return {
    getCaps: (channel?: number) => {
      return this.send<{ caps: unknown }>("VideoInAnalyse.getCaps", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params.caps;
      });
    },
    getTemplateRule: (Class: unknown, channel?: number) => {
      return this.send("VideoInAnalyse.getTemplateRule", {
        channel: channel || 0,
        class: Class,
      }).then(function (a) {
        return a.params;
      });
    },
    getTemplateGlobal: (channel?: number) => {
      return this.send("VideoInAnalyse.getTemplateGlobal", {
        channel: channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    getTemplateModule: (Class: unknown, channel?: number) => {
      return this.send("VideoInAnalyse.getTemplateModule", {
        channel: channel || 0,
        class: Class,
      }).then(function (a) {
        return a.params;
      });
    },
    getTemplateSceneSnapShotWithRule2: (
      Class: unknown,
      Channel?: number,
      RuleType?: unknown
    ) => {
      return this.send("VideoInAnalyse.getTemplateSceneSnapShotWithRule2", {
        Channel: Channel || 0,
        Class: Class,
        RuleType: RuleType,
      }).then(function (a) {
        return a.params;
      });
    },
    getTemplateTrafficViolationCode: (Channel?: number) => {
      return this.send("VideoInAnalyse.getTemplateTrafficViolationCode", {
        Channel: Channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    getTemplatePresetRecord: (Channel?: number) => {
      return this.send("VideoInAnalyse.getTemplatePresetRecord", {
        Channel: Channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    getTemplatePresetImage: (Channel?: number) => {
      return this.send("VideoInAnalyse.getTemplatePresetImage", {
        Channel: Channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    getTemplateTrafficSnapMosaic2: (Channel?: number) => {
      return this.send("VideoInAnalyse.getTemplateTrafficSnapMosaic2", {
        Channel: Channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
    getNewTemplateTrafficSnapMosaic2: (
      Chanel?: number,
      Class?: unknown,
      Rule?: unknown
    ) => {
      return this.send("VideoInAnalyse.getTemplateTrafficSnapMosaic2", {
        Channel: Chanel || 0,
        Class: Class,
        Rule: Rule,
      }).then(function (a) {
        return a.params;
      });
    },
    getTemplateSnapOSD: (Class: unknown, Channel?: number) => {
      return this.send("VideoInAnalyse.getTemplateSnapOSD", {
        Channel: Channel || 0,
        Class: Class,
      }).then(function (a) {
        return a.params;
      });
    },
    getTemplateCalibrate: (Channel?: number) => {
      return this.send("VideoInAnalyse.getTemplateCalibrate", {
        Channel: Channel || 0,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/VideoProcessManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function VideoProcessManager(this: RPCBase) {
  return {
    getCaps: (name?: unknown, channel?: number) => {
      return this.send<{ caps: unknown }>("VideoProcessManager.getCaps", {
        name: name,
        channel: channel || 0,
      }).then(function (a) {
        return a.params.caps;
      });
    },
  };
}



================================================
FILE: lib/rpc/VideoStatServer.ts
================================================
import { RPCBase } from "../rpcBase";

export function VideoStatServer(this: RPCBase) {
  const instance = this.sendSetup("videoStatServer.factory.instance");
  return {
    instance,
    clearSectionStat: (
      channel?: number,
      AreaID?: number,
      PtzPresetId?: number
    ) => {
      let e: { AreaID?: number; PtzPresetId?: number } | null = {};
      return (
        void 0 !== AreaID && (e.AreaID = AreaID),
        void 0 !== PtzPresetId && (e.PtzPresetId = PtzPresetId),
        void 0 === AreaID && void 0 === PtzPresetId && (e = null),
        instance({ channel: channel || 0 }).then((a) => {
          return this.send("videoStatServer.clearSectionStat", e, {
            object: a.result,
          });
        })
      );
    },
    startFind: (condition: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "videoStatServer.startFind",
          { condition: condition },
          { object: a.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
    doFind: (
      token: unknown,
      beginNumber: unknown,
      count: unknown,
      channel?: number
    ) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "videoStatServer.doFind",
          { token: token, beginNumber: beginNumber, count: count },
          { object: a.result }
        ).then(function (a) {
          return a.params;
        });
      });
    },
    stopFind: (token: unknown, channel?: number) => {
      return instance({ channel: channel || 0 }).then((a) => {
        return this.send(
          "videoStatServer.stopFind",
          { token: token },
          { object: a.result }
        );
      });
    },
  };
}



================================================
FILE: lib/rpc/WebInit.ts
================================================
import { RPCBase } from "../rpcBase";

export function WebInit(this: RPCBase) {
  return {
    getCaps: () => {
      return this.send("WebInit.getCaps", void 0, void 0, "/OutsideCmd") // , !1)
        .then(function (a) {
          return a && a.params;
        });
    },
  };
}



================================================
FILE: lib/rpc/WideViewControl.ts
================================================
import { RPCBase } from "../rpcBase";

export function WideViewControl(this: RPCBase) {
  const instance = this.sendSetup("wideViewControl.factory.instance");
  return {
    instance,
    getCaps: (channel: unknown, capsName: unknown) => {
      return instance({ channel: channel }).then((a) => {
        return this.send<{ caps: unknown }>(
          "wideViewControl.getCaps",
          { capsName: capsName },
          { object: a.result }
        ).then(function (a) {
          return a.params.caps;
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/wire802File.ts
================================================
import { RPCBase } from "../rpcBase";

export function wire802File(this: RPCBase) {
  return {
    importCACert: (Interface: unknown, content: unknown) => {
      return this.send("Wire802_1X.importCACert", {
        interface: Interface,
        content: content,
      }).then(function (a) {
        return a;
      });
    },
    importClientCert: (Interface: unknown, content: unknown) => {
      return this.send("Wire802_1X.importClientCert", {
        interface: Interface,
        content: content,
      }).then(function (a) {
        return a;
      });
    },
    importClientKey: (Interface: unknown, content: unknown) => {
      return this.send("Wire802_1X.importClientKey", {
        interface: Interface,
        content: content,
      }).then(function (a) {
        return a;
      });
    },
  };
}



================================================
FILE: lib/rpc/WlanManager.ts
================================================
import { RPCBase } from "../rpcBase";

export function WlanManager(this: RPCBase) {
  return {
    getCaps: () => {
      return this.send("WlanManager.getCaps").then(function (a) {
        return a.params;
      });
    },
    getWlanBandType: (Name: unknown) => {
      return this.send("WlanManager.getWlanBandType", { Name: Name }).then(
        function (a) {
          return a.params;
        }
      );
    },
    getSTAInfo: (EthName: unknown, StaNum: unknown) => {
      return this.send("WlanManager.getSTAInfo", {
        EthName: EthName,
        StaNum: StaNum,
      }).then(function (a) {
        return a.params;
      });
    },
  };
}



================================================
FILE: lib/rpc/WorkDirectory.ts
================================================
import { RPCBase } from "../rpcBase";

export function WorkDirectory(this: RPCBase) {
  const instance = this.sendSetup("workDirectory.factory.instance");
  return {
    instance,
    getInfo: (name: string) => {
      return instance({ name: name }).then((a) => {
        return this.send<{ info: unknown }>("workDirectory.getInfo", null, {
          object: a.result,
        }).then(function (a) {
          return a.params.info;
        });
      });
    },
    setGroup: (name: string, group: unknown) => {
      return instance({ name: name }).then((a) => {
        return this.send(
          "workDirectory.setGroup",
          { group: group },
          { object: a.result }
        );
      });
    },
    /**
     * Gets bitmap for month which shows if there is any footage.
     * Throws an error if there was no footage.
     * @param name Storage path (ex. /dev/mmc0).
     */
    getBitmapEx: (
      name: string,
      condition: {
        Channel: number;
        Types: ["dav"] | ["jpg"] | ["dav", "jpg"] | ["jpg", "dav"];
        Events: "*";
        Year: number;
        Month: number;
      }
    ) => {
      return instance({ name: name }).then((a) => {
        return this.send<{ bitmap: number }>(
          "workDirectory.getBitmapEx",
          { condition: condition },
          { object: a.result }
        ).then(function (a) {
          return a.params.bitmap;
        });
      });
    },
    releaseDirectory: (name: string) => {
      return instance({ name: name }).then((a) => {
        return this.send<{ info: unknown }>(
          "workDirectory.releaseDirectory",
          null,
          {
            object: a.result,
          }
        ).then(function (a) {
          return a.params.info;
        });
      });
    },
    getSpaceInfoByFileType: (name: string, FileType: unknown) => {
      return instance({ name: name }).then((a) => {
        return this.send<{ info: unknown }>(
          "workDirectory.getSpaceInfoByFileType",
          { FileType: FileType },
          { object: a.result }
        ).then(function (a) {
          return a.params.info;
        });
      });
    },
  };
}



================================================
FILE: lib/rpc/WorkGroup.ts
================================================
import { RPCBase } from "../rpcBase";

export function WorkGroup(this: RPCBase) {
  const instance = this.sendSetup("workGroup.factory.instance");
  return {
    instance,
    getDirectories: (name: unknown) => {
      return instance({ name: name }).then((a) => {
        return this.send<{ list: unknown }>("workGroup.getDirectories", null, {
          object: a.result,
        }).then(function (a) {
          return a.params.list;
        });
      });
    },
  };
}



================================================
FILE: lib/rpcBase/Global.ts
================================================
import { RPCBase } from ".";

export function Global(this: RPCBase) {
  return {
    firstLogin: (username: string, params?: object, clientType?: string) => {
      const data = {
        method: "global.login",
        params: {
          userName: username,
          password: "",
          clientType: clientType ? clientType : "Web3.0",
          ...params,
        },
        id: this._nextID(),
      };

      return this.sendRPCRaw<{
        authorization: string;
        encryption: string;
        random: string;
        realm: string;
      }>(data, "/RPC2_Login").then((a) => {
        this._setSession(username, a.data.session);
        return a.data;
      });
    },
    secondLogin: (
      username: string,
      password: string,
      params?: object,
      clientType?: string
    ) => {
      return this.sendRPC<
        { remainLockSecond: number; remainLoginTimes: number } | unknown
      >(
        this.rpc("global.login", {
          userName: username,
          password: password,
          clientType: clientType ? clientType : "Web3.0",
          ...params,
        }),
        "/RPC2_Login"
      );
    },
    logout: () => {
      return this.sendRPC(this.rpc("global.logout"), null);
    },
    keepAlive: (timeout?: number) => {
      return this.sendRPC<{ timeout: number }>(
        this.rpc("global.keepAlive", { timeout: timeout || 300, active: true })
      ).then(function (a) {
        return a.params.timeout;
      });
    },
    getCurrentTime: () => {
      return this.sendRPC<{ time: string }, string | boolean>(
        this.rpc("global.getCurrentTime")
      ).then(function (b) {
        return "string" === typeof b.result ? b.result : b.params.time;
      });
    },
    setCurrentTime: (time: string, tolerance: unknown) => {
      return this.sendRPC(
        this.rpc("global.setCurrentTime", { time: time, tolerance: tolerance })
      );
    },
  };
}



================================================
FILE: lib/rpcBase/index.ts
================================================
import axios from "axios";
import http from "http";
import https from "https";
import { Global } from "./Global";

export enum Code {
  ERROR_CODE_NOT_SET = 268959743,
  INTERFACE_NOT_FOUND = 268632064,
  METHOD_NOT_FOUND = 268894210,
  REQUEST_INVALID = 268894209,
  REQUEST_INVALID_PARAM = 268894211,
  SESSION_INVALID = 28763750,

  USER_NOT_VALID = 268632070,
  PASSWORD_NOT_VALID = 268632071,
  IN_BLACK_LIST = 268632073,
  HAS_BEEN_USED = 268632074,
  HAS_BEEN_LOCKED = 268632081,

  BUSY = 268632075,
}

export type TRPC = object;

export type TResponse<T = unknown, R = boolean> = {
  id: number;
  error?: { code: number; message: string };
  params: T;
  result: R;
  session: string;
};

export type TOptions = {
  protocol?: "http" | "https";
  rpcURI?: string;
};

const axiosInstance = axios.create({
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),
});

/**
 * Base RPC class that can send RPC and has the Global module.
 */
export class RPCBase {
  readonly baseURL;
  readonly rpcURI;
  _id = 0;
  _session = "";
  _username = "";

  Global = Global.bind(this)();

  /**
   * @param address ip or ip:port
   */
  constructor(address: string, options: TOptions = {}) {
    this.baseURL = `${options.protocol ?? "http"}://${address}`;
    this.rpcURI = options.rpcURI ?? "/RPC2";
  }

  _nextID(): number {
    return this._id++;
  }

  _setSession(username: string, session: string) {
    this._username = username;
    this._session = session;
  }

  getSessionUsername(): string {
    return this._username;
  }

  getSession(): string {
    return this._session;
  }

  /**
   * Generate a RPC.
   * @param method The method to call on the remote device.
   * @param params The arguments to pass to the method.
   * @param options Extra options for the RPC.
   * @returns
   */
  rpc(method: string, params?: object | null, options?: object): TRPC {
    return {
      method: method,
      params: params || null,
      id: this._nextID(),
      session: this.getSession(),
      ...options,
    };
  }

  /**
   * Send RPC without inspecting response for errors.
   */
  sendRPCRaw<T, R = boolean>(rpc: TRPC, uri?: string | null) {
    return axiosInstance.post<TResponse<T, R>>(
      this.baseURL + (uri || this.rpcURI),
      JSON.stringify(rpc)
    );
  }

  /**
   * Send RPC.
   */
  sendRPC<T, R = boolean>(rpc: TRPC, uri?: string | null) {
    return new Promise<TResponse<T, R>>((resolve, reject) => {
      this.sendRPCRaw<T, R>(rpc, uri)
        .then((b) => {
          if (b.data.result) {
            return resolve(b.data);
          }

          if (
            b.data.error &&
            b.data.error.code &&
            Code.SESSION_INVALID === b.data.error.code
          ) {
            // TODO: publish SessionInvalid event
          }

          reject(b.data);
        })
        .catch((e) => {
          reject(e);
        });
    });
  }

  /**
   * Generate and send a single or multiple RPC.
   * @param methodOrArray Method or an array of methods.
   * @param paramsOrArray Parameter or an array of parameters.
   */
  send<T, R = boolean>(
    methodOrArray: string[] | string,
    paramsOrArray?: object[] | object | null,
    options?: object,
    uri?: string
  ) {
    const multicalls: TRPC[] = [];

    if (Array.isArray(methodOrArray) && Array.isArray(paramsOrArray)) {
      methodOrArray.forEach((method, index) => {
        multicalls.push(this.rpc(method, paramsOrArray[index], options));
      });
      return this.sendRPC<T, R>(this.rpc("system.multicall", multicalls), uri);
    }

    if (typeof methodOrArray == "string" && Array.isArray(paramsOrArray)) {
      paramsOrArray.forEach((params) => {
        multicalls.push(this.rpc(methodOrArray, params, options));
      });
      return this.sendRPC<T, R>(this.rpc("system.multicall", multicalls), uri);
    }

    if (Array.isArray(methodOrArray)) {
      methodOrArray.forEach((method) => {
        multicalls.push(this.rpc(method, paramsOrArray, options));
      });
      return this.sendRPC<T, R>(this.rpc("system.multicall", multicalls), uri);
    }

    return this.sendRPC<T, R>(
      this.rpc(methodOrArray, paramsOrArray, options),
      uri
    );
  }

  /**
   * Create instance that is used for other send calls.
   * @param method setup method.
   * @param useCache Use cached response if available.
   */
  sendSetup<T, R = boolean>(method: string, useCache = true) {
    let data: Record<string, Record<string, Promise<TResponse<T, R>>>> = {};
    return (params?: object, options?: object) => {
      const session = this.getSession();
      const json = JSON.stringify({ ...params, ...options });

      if (session in data && json in data[session] && useCache) {
        return new Promise<TResponse<T, R>>((resolve) => {
          data[session][json]
            .then(() => resolve(data[session][json]))
            .catch(() => {
              resolve(
                (data[session][json] = this.send<T, R>(method, params, options))
              );
            });
        });
      }

      return data[session]
        ? (data[session][json] = this.send<T, R>(method, params, options))
        : ((data = {}),
          (data[session] = {}),
          (data[session][json] = this.send<T, R>(method, params, options)));
    };
  }
}



================================================
FILE: test/env.ts
================================================
import * as dotenv from "dotenv";

function parse(name: string) {
  const value = process.env[name];
  if (typeof value === "string") {
    return value;
  }

  return "";
}

dotenv.config();

const username = parse("RPC_USERNAME");
const password = parse("RPC_PASSWORD");
const ips = parse("RPC_IP").split(",");
const ip = ips[0] || "";

export default {
  username,
  password,
  ip,
  ips,
};



================================================
FILE: test/rpc.spec.ts
================================================
import { expect } from "chai";
import { describe, it } from "mocha";
import { RPC, RPCLogin } from "../lib";
import env from "./env";

describe("rpc", function () {
  const { ip } = env;
  const rpc = new RPC(ip);
  const rpcLogin = new RPCLogin(rpc);

  before(function () {
    const { username, password } = env;
    return rpcLogin.login(username, password);
  });

  after(function () {
    return rpcLogin.logout();
  });

  describe("MagicBox", function () {
    it("getSerialNo", async function () {
      const sn = await rpc.MagicBox.getSerialNo();
      expect(sn).to.be.a("string", "serial number").to.be.not.empty;
    });

    it("getUpTime", async function () {
      const uptime = await rpc.MagicBox.getUpTime();
      expect(uptime.Last).to.be.a("number", "Uptime");
      expect(uptime.Total).to.be.a("number", "Total Uptime");
    });
  });

  describe("ConfigManager", function () {
    it("getConfig('Encode')", async function () {
      await rpc.ConfigManager.getConfig("Encode");
    });
  });
});



================================================
FILE: test/rpcLogin.spec.ts
================================================
import { expect } from "chai";
import { describe, it } from "mocha";
import { RPCBase, RPCLogin } from "../lib";
import env from "./env";

describe("rpcLogin", function () {
  const { username, password, ips } = env;

  for (const ip of ips) {
    describe(`${ip}`, async function () {
      it("should login, get current time, and logout", function () {
        const rpcBase = new RPCBase(ip);
        const rpcLogin = new RPCLogin(rpcBase);

        return rpcLogin.login(username, password).then(() => {
          return rpcBase.Global.getCurrentTime()
            .then((time) => {
              expect(time).to.be.a("string", "current time").to.not.be.empty;
            })
            .finally(() => rpcLogin.logout());
        });
      });
    });
  }
});



================================================
FILE: test/util.spec.ts
================================================
import { expect } from "chai";
import {
  toTimestamp,
  dayInBitmap,
  daysFromBitmap,
  fromTimestamp,
} from "../lib/util";

describe("util", function () {
  describe("bitmap", function () {
    const bitmap = 250;
    const days = [1, 3, 4, 5, 6, 7];

    it("dayInBitmap", function () {
      expect(dayInBitmap(bitmap, 2)).to.be.false;
      expect(dayInBitmap(bitmap, 20)).to.be.false;
      expect(dayInBitmap(bitmap, 31)).to.be.false;
      for (const day of days) {
        expect(dayInBitmap(bitmap, day)).to.be.true;
      }
    });

    it("daysFromBitmap", function () {
      expect(daysFromBitmap(bitmap)).deep.eq(days);
    });
  });

  describe("timestamp", function () {
    [
      "2023-02-06 00:00:00",
      "2023-02-06 03:09:09",
      "2023-02-06 23:59:59",
    ].forEach((timestamp) => {
      it(timestamp, function () {
        expect(toTimestamp(fromTimestamp(timestamp))).to.be.eq(timestamp);
      });
    });
  });
});



================================================
FILE: .github/workflows/npm-publish.yml
================================================
# This workflow will run tests using node and then publish a package to GitHub Packages when a release is created
# For more information see: https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages

name: Node.js Package

on:
  push:
    tags:
      - "v*.*.*"

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 16
      - run: npm ci
      - run: npm test

  publish-npm:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 16
          registry-url: https://registry.npmjs.org/
      - run: npm ci
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{secrets.npm_token}}


